# 从输入 url 到页面渲染

## 一、用户输入 url 开始进行 url 解析
1. **浏览器进程**中的UI thread线程负责用户界面的交互，控制浏览器上的按钮及输入框。当你在地址栏输入 URL 时，UI thread责捕捉这个输入。会判断输入的内容是搜索关键词（search query）还是URL。
2. 按下回车键后，主进程解析 URL，管理标签页的创建和切换，以及启动相应的渲染进程来加载网页。

-  **输入搜索关键词：** 地址栏会使⽤浏览器默认的搜索引擎，来合成新的带搜索关键字的URL ==（关键字需要进行encodeURIComponent处理）==
- **输入 url：** 地址栏会根据规则，给这段内容加上协议，合成为完整的URL；

## 二、浏览器进程通过进程间通信（IPC）把url请求发送给⽹络进程；


## 三、是否有强缓存，是否命中协商缓存，没有缓存则发起 http请求
即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。

## 四、进行DNS解析、是否有 DNS 缓存、没有发起递归解析，获取 ip 地址后发起请求

## 五、建立 TCP 连接

## 六、发送 http 请求
1. 三次握手 + tls握手
2. 四次挥手

## 七、读取响应
1. 网络进程接收到服务器的响应后，开始解析HTTP响应报文，然后根据响应头中的`Content-Type`字段来确定响应主体的**媒体类型**（MIME Type）。
2. 如果媒体类型是一个`HTML`文件，则将响应数据交给**渲染进程**（renderer process）来进行下一步的工作，如果是 `zip` 文件或者其它文件，会把相关数据传输给**下载管理器**。
3. 与此同时，浏览器会进行 Safe Browsing 安全检查，如果域名或者请求内容匹配到已知的恶意站点，网络进程会展示一个警告页。
4. 除此之外，网络进程还会做 CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程。

## 八、查找渲染进程
- 各种检查完毕以后，网络进程确信浏览器可以导航到请求网页，网络进程会通知浏览器进程的 UI thread 数据已经准备好，UI thread 会查找到一个 renderer process 进行网页的渲染。
- 浏览器为了对查找渲染进程这一步骤进行优化，考虑到网络请求获取响应需要时间，所以导航开始时，浏览器已经预先查找和启动了一个渲染进程，如果中间步骤一切顺利，当网络进程接收到数据时，渲染进程已经准备好了，但是如果遇到重定向，这个准备好的渲染进程也许就不可用了，这个时候会重新启动一个渲染进程。
- 浏览器进程检查当前url是否与之前打开了渲染进程的⻚⾯的根域名相同，如果相同，则复⽤原来的进程，如果不同，则开启新的渲染进程


## 九、提交导航
- 到了这一步，数据和渲染进程都准备好了，Browser Process 会向 Renderer Process 发送IPC消息来确认导航，此时，网络进程将准备好的数据发送给渲染进程，渲染进程接收到数据之后，又发送IPC消息给浏览器进程，告诉浏览器进程导航已经提交了，页面开始加载。
- 这个时候导航栏会更新，安全指示符更新（地址前面的小锁），访问历史列表（history tab）更新，即可以通过前进后退来切换该页面。

## 十、渲染过程

### **1.解析HTML构建DOM树**
- 边解析边构建
```
Bytes → characters → tokens → nodes → DOM
```
1. **Conversion转换**：浏览器将获得的HTML内容（**Bytes**）基于他的编码转换为**单个字符**
2. **Tokenizing分词**：浏览器**按照HTML规范标准**将这些**字符**转换为不同的标记**token**。每个token都有自己独特的含义以及规则集
3. **Lexing词法分析**：分词的结果是得到一堆的token，此时把他们转换为**node对象**，这些对象分别定义他们的**属性和规则**
   - **注意**：渲染引擎还有⼀个安全检查模块叫 XSSAuditor，是⽤来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，⽐如是否引⽤了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内XSSAuditor 会对该脚本或者下载任务进⾏拦截。 
4. **DOM构建**：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样
5. **⾸次解析HTML时渲染进程会开启⼀个预解析线程**：在构建DOM的过程中，**会解析到**图片、CSS、JavaScript脚本等资源，这些资源是需要从网络或者缓存中获取的，主线程在构建DOM过程中如果遇到了这些资源，逐一发起请求去获取，而为了提升效率，浏览器也会运行预加载扫描（preload scanner）程序，如果HTML中存在img、link等标签，预加载扫描程序会把这些请求传递给网络进程进行资源下载。
但是不能对优先级进行控制，例如 css 引用字体，要等，css 下载完后再下载字体，造成页面闪烁。或者首屏不需要的 css 也提前下载，阻塞首屏渲染。这时就需要 preload
### **2.构建CSSOM并进行样式计算**
在计算完样式之后，所有的样式值会被挂在到`window.getComputedStyle`当中，也就是可以通过JS来获取计算后的样式
#### 需要解析的三类元素
1. 通过 link 引用的外部 CSS 文件
2. `<style>`标签内的样式
3. 元素的 style 属性内嵌的 CSS

#### 1.格式化样式表
```
Bytes → characters → tokens → nodes → CSSOM
```
在控制台打印document.styleSheets，这就是解析出的样式表
#### 2.标准化样式属性
有一些 CSS 样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，⽐如将em转换为px，color转换为rgb等等。
#### 3.计算每个节点的具体样式
样式已经被**格式化**和**标准化**,接下来就可以计算**每个节点**的具体**样式信息**了.
1. **继承**:每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫UserAgent样式
2. **层叠**: 也就是最终的样式取决于各个属性共同作用的效果

### **3.生成布局树(Layout Tree)**
- 现在已经生成了DOM树和DOM样式，接下来要做的就是通过浏览器的布局系统**确定元素的位置**，也就是要生成一棵布局树(Layout Tree)。布局（Layout）其实就是找到所有元素的**几何关系**的过程。
- 一般来说，布局树和DOM树相对应的，但不是严格意义上的一一对应.如`head`这种不可见的标签或者`display: none`等.

1. 遍历生成的 DOM 树节点，并把他们添加到布局树中。
2. 计算布局树节点的坐标位置。


## 十一、初始化加载完成
当导航提交完成后，渲染进程开始加载资源及渲染页面，当页面渲染完成后（页面及内部的iframe都触发了onload事件），会向浏览器进程发送IPC消息，告知浏览器进程，这个时候UI thread会停止展示tab中的加载中图标。

