# 从输入 url 到页面渲染

## 一、用户输入 url 开始进行 url 解析
1. **浏览器进程**中的UI thread线程负责用户界面的交互，控制浏览器上的按钮及输入框。当你在地址栏输入 URL 时，UI thread责捕捉这个输入。会判断输入的内容是搜索关键词（search query）还是URL。
2. 按下回车键后，主进程解析 URL，管理标签页的创建和切换，以及启动相应的渲染进程来加载网页。

-  **输入搜索关键词：** 地址栏会使⽤浏览器默认的搜索引擎，来合成新的带搜索关键字的URL ==（关键字需要进行encodeURIComponent处理）==
- **输入 url：** 地址栏会根据规则，给这段内容加上协议，合成为完整的URL；

## 二、浏览器进程通过进程间通信（IPC）把url请求发送给⽹络进程；


## 三、是否有强缓存，是否命中协商缓存，没有缓存则发起 http请求
即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。

## 四、进行DNS解析、是否有 DNS 缓存、没有发起递归解析，获取 ip 地址后发起请求

## 五、建立 TCP 连接

## 六、发送 http 请求
1. 三次握手 + tls握手
2. 四次挥手

## 七、读取响应
1. 网络进程接收到服务器的响应后，开始解析HTTP响应报文，然后根据响应头中的`Content-Type`字段来确定响应主体的**媒体类型**（MIME Type）。
2. 如果媒体类型是一个`HTML`文件，则将响应数据交给**渲染进程**（renderer process）来进行下一步的工作，如果是 `zip` 文件或者其它文件，会把相关数据传输给**下载管理器**。
3. 与此同时，浏览器会进行 Safe Browsing 安全检查，如果域名或者请求内容匹配到已知的恶意站点，网络进程会展示一个警告页。
4. 除此之外，网络进程还会做 CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程。

## 八、查找渲染进程
- 各种检查完毕以后，网络进程确信浏览器可以导航到请求网页，网络进程会通知浏览器进程的 UI thread 数据已经准备好，UI thread 会查找到一个 renderer process 进行网页的渲染。
- 浏览器为了对查找渲染进程这一步骤进行优化，考虑到网络请求获取响应需要时间，所以导航开始时，浏览器已经预先查找和启动了一个渲染进程，如果中间步骤一切顺利，当网络进程接收到数据时，渲染进程已经准备好了，但是如果遇到重定向，这个准备好的渲染进程也许就不可用了，这个时候会重新启动一个渲染进程。
- 浏览器进程检查当前url是否与之前打开了渲染进程的⻚⾯的根域名相同，如果相同，则复⽤原来的进程，如果不同，则开启新的渲染进程


## 九、提交导航
- 到了这一步，数据和渲染进程都准备好了，Browser Process 会向 Renderer Process 发送IPC消息来确认导航，此时，网络进程将准备好的数据发送给渲染进程，渲染进程接收到数据之后，又发送IPC消息给浏览器进程，告诉浏览器进程导航已经提交了，页面开始加载。
- 这个时候导航栏会更新，安全指示符更新（地址前面的小锁），访问历史列表（history tab）更新，即可以通过前进后退来切换该页面。

## 十、解析 html 过程

### **1.解析HTML构建DOM树**
- 边解析边构建
```
Bytes → characters → tokens → nodes → DOM
```
1. **Conversion转换**：浏览器将获得的HTML内容（**Bytes**）基于他的编码转换为**单个字符**
2. **Tokenizing分词**：浏览器**按照HTML规范标准**将这些**字符**转换为不同的标记**token**。每个token都有自己独特的含义以及规则集
3. **Lexing词法分析**：分词的结果是得到一堆的token，此时把他们转换为**node对象**，这些对象分别定义他们的**属性和规则**
   - **注意**：渲染引擎还有⼀个安全检查模块叫 XSSAuditor，是⽤来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，⽐如是否引⽤了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内XSSAuditor 会对该脚本或者下载任务进⾏拦截。 
4. **DOM构建**：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样
5. **⾸次解析HTML时渲染进程会开启⼀个预解析线程**：在构建DOM的过程中，**会解析到**图片、CSS、JavaScript脚本等资源，这些资源是需要从网络或者缓存中获取的，主线程在构建DOM过程中如果遇到了这些资源，逐一发起请求去获取，而为了提升效率，浏览器也会运行预加载扫描（preload scanner）程序，如果HTML中存在img、link等标签，预加载扫描程序会把这些请求传递给网络进程进行资源下载。
但是不能对优先级进行控制，例如 css 引用字体，要等，css 下载完后再下载字体，造成页面闪烁。或者首屏不需要的 css 也提前下载，阻塞首屏渲染。这时就需要 preload
### **2.构建CSSOM并进行样式计算**
在计算完样式之后，所有的样式值会被挂在到`window.getComputedStyle`当中，也就是可以通过JS来获取计算后的样式
#### 需要解析的三类元素
1. 通过 link 引用的外部 CSS 文件
2. `<style>`标签内的样式
3. 元素的 style 属性内嵌的 CSS
#### 1.格式化样式表
```
Bytes → characters → tokens → nodes → CSSOM
```
在控制台打印document.styleSheets，这就是解析出的样式表
#### 2.标准化样式属性
有一些 CSS 样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，⽐如将em转换为px，color转换为rgb等等。
#### 3.计算每个节点的具体样式
样式已经被**格式化**和**标准化**,接下来就可以计算**每个节点**的具体**样式信息**了.
1. **继承**:每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫UserAgent样式
2. **层叠**: 也就是最终的样式取决于各个属性共同作用的效果

## 十一、渲染过程
==在CSS属性改变时，重渲染会分为“**回流**”、“**重绘**”和“**直接合成**”三种情况，分别对应从“**布局定位**”/“**图层绘制**”/“**合成显示**”==
1. **回流（又叫重排**）：元素位置、大小发生变化导致其他节点联动，需要重新计算布局；
2. **重绘**：修改了一些不影响布局的属性，比如颜色；
3. **直接合成**：合成层的transform、opacity修改，只需要将多个图层再次合并，而后生成位图，最终展示到屏幕上；
### **1.生成布局树(Layout Tree)** 布局（Layout）
- 现在已经生成了DOM树和DOM样式，接下来要做的就是通过浏览器的布局系统**确定元素的位置**，也就是要生成一棵布局树(Layout Tree)。布局（Layout）其实就是找到所有元素的**几何关系**的过程。
- 一般来说，布局树和DOM树相对应的，但不是严格意义上的一一对应.如`head`这种不可见的标签或者`display: none`等.
- Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为回流 **（Reflow）**

1. 遍历生成的 DOM 树节点，并把他们添加到布局树中。
2. 计算布局树节点的坐标位置。

### **2.绘制过程 （Paint）**
这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为重绘 **（Repaint）**
#### 1.建立图层树-合成层
- 生成布局树后还需要考虑3D动画如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等等
- 为了解决如上所述的问题，浏览器在构建完布局树之后，还会对特定的节点进行分层，构建一棵图层树 **(Layer Tree)**。
##### 1.生成渲染层的条件
1. 创建层叠上下文的节点
2. 此外需要剪裁的元素也会形成一个渲染层，也就是overflow不是visible的元素。比如一个div，你只给他设置 100 * 100 像素的大小，而你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。
##### 2.合成层
在开发者工具中看到的不是渲染层，而是下面要讲的合成层，只有一些**特殊的渲染层**才会被提升为合成层，通常来说有这些情况：
1. 产生 滚动条 的元素
2. 滚动条 单独生成图层
3. 产生 滚动的内容 单独生成图层
4. HTML 根元素
5. video 元素
6. canvas 元素
7. iframe 标签
8. 拥有 CSS3 动画 的元素，对 opacity | transform | fliter 应用了过渡和动画（transition/animation）
9. position：fixed 的定位元素
10. transform:3D变换：translate3d，translateZ
11. 拥有 CSS will-change 属性的元素  opacity、transform、transform-style、perspective、filter、backdrop-filter 
可以看出，上面这些条件属于生成渲染层的“加强版”，也就是说形成合成层的条件要更苛刻。

##### 3.利用合成层优化
- 之所以叫硬件加速，就是因为合成层会交给GPU（显卡）去处理，在硬件层面上开外挂，比在主线程（CPU）上效率更高。
- 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
**方案：**
1. 避免重排/重绘，直接进行合成，合成层的transform 和 opacity的修改都是直接进入合成阶段的；比如可以使用transform:translate代替left/top修改元素的位置；使用transform:scale代替宽度、高度的修改；
2. 注意隐式合成，给合成层一个较大的z-index值，虽然大部分浏览器已经实现了层压缩的能力，但是依旧有无法处理的情况，最好的办法就是一开始就避免层爆炸
3. 减小合成层占用的内存，合成层的最大问题就是占用内存较多，而内存的占用和元素的尺寸是成正比的，如果要实现一个100X100的元素，可以给宽高都设置为10px，再使用transform:scale(10)放大10倍，这样占用的内存只有直接设置的1/100
4. 使用visibility不触发重排，但是依然重绘。直接使用opacity即触发重绘，又触发重排（GPU底层设计）。opacity配合图层使用，既不触发重绘也不触发重排。原因：
透明度的改变时候，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。不过这个前提是这个被修改opacity本身必须是一个图层
**缺点：**
1. 绘制的图层必须传输到 GPU，这些层的数量和大小达到一定量级后，可能会导致传输非常慢，进而导致一些低端和中端设备上出现闪烁。
2. 隐式合成容易产生过量的合成层，每个合成层都占用额外的内存，而内存是移动设备上的宝贵资源，过多使用内存可能会导致浏览器崩溃，让性能优化适得其反
##### 4.隐式合成
- 简单来说就是层叠等级低的节点被提升为单独的图层之后，那么所有层叠等级比它高的节点都会成为一个单独的图层。
- 如果在一个大型应用中，当一个z-index比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是**层爆炸的原理**。
##### 5.层爆炸
- 隐式合成产生了很多预期外的合成层——页面中所有 z-index 高于它的节点全部被提升，这些合成层都是相当消耗内存和GPU的。所以带给我们的启示是给合成层一个大的z-index值，避免出现隐式合成。
- 由于 animation transform 的特殊性（动态交叠不确定），隐式合成在不需要交叠的情况下也能发生，就导致了页面中所有 z-index 高于它的节点所对应的渲染层全部提升为合成层，最终让这个页面整整产生了几千个合成层。

##### 6.层压缩
- 如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。
- 当然了，浏览器的自动层压缩并不是万能的，有很多特定情况下，浏览器是无法进行层压缩的

### **3.生成绘制列表** paint records
- 接下来渲染引擎会将图层的绘制拆分成一个个绘制指令，比如先画背景、再描绘边框......然后将这些指令按**顺序**组合成一个待绘制列表，相当于给后面的绘制操作做了一波计划。
- 绘画记录可以看做是记录各元素绘制先后顺序的笔记
- 以上操作都是在渲染进程中的**主线程**中进⾏的
- 绘制列表准备好了之后，渲染进程的主线程会给合成线程发送commit消息，把绘制列表提交给**合成线程**。接下来就是合成线程一展宏图的时候啦。

## 十二、合成线程
### **什么是合成？**
- 合成是一种将页面分成若干层，然后分别对它们进行光栅化，最后在一个单独的线程 - 合成线程（compositor thread）里面合并成一个页面的技术。
- 当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。
- 渲染引擎跳过布局和绘制阶段，执⾏的后续操作，发⽣在合成线程，⾮主线程
### 合成操作
- 首先，考虑到视口就这么大，当页面非常大的时候，要滑很长时间才能滑到底，如果要一口气全部绘制出来是相当浪费性能的。
- 因此，**合成线程**要做的第一件事情就是将**图层分块**。这些块的大小一般不会特别大，通常是 256 * 256 或者 512 * 512 这个规格。这样可以大大加速页面的首屏展示。
- 因为后面**图块**数据要进入 **GPU** 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，也可能会耗费大量时间。
- 在首次合成图块时只采用一个**低分辨率**的图片，这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，会将当前低分辨率的图块内容**替换**。
- 合成线程将图层切分成⼤⼩固定的图块（256x256或者512x512）然后**优先绘制靠近视⼝**的图块，这样就可以⼤⼤加速⻚⾯的显示速度
- 当图层上面的图块都被栅格化后，合成线程会收集**图块上面**叫做**绘画四边形**（draw quads）的信息来构建**一个合成帧**（compositor frame）
  - 绘画四边形：包含图块在内存的位置以及图层合成后图块在页面的位置之类的信息。
  - 合成帧：代表页面一个帧的内容的绘制四边形集合。
- 以上所有步骤完成后，**合成线程**就会通过`IPC`向**浏览器进程**（browser process）提交（commit）**一个渲染帧**。

### 合成的好处
- 合成的好处在于这个过程没有涉及到主线程，所以合成线程不需要等待样式的计算以及JavaScript完成执行。
- 这就是为什么合成器相关的动画最流畅，如果某个动画涉及到布局或者绘制的调整，就会涉及到主线程的重新计算，自然会慢很多。

## 十三、光栅化线程
- 有的层的可以达到整个页面的大小，所以合成线程需要将它们切分为一块又一块的**小图块**（tiles）
- 之后将这些小图块分别进行发送给**一系列光栅线程**（raster threads）进行**光栅化**，结束后光栅线程会将每个图块的光栅结果 **(位图数据)**存在`GPU Process`的**内存**中。
- 生成位图的过程实际上都会使用 GPU 进行加速
- 为了优化显示体验，合成线程可以给**不同的光栅线程**赋予不同的优先级，将那些在视口中的或者视口附近的层先被光栅化。

## 十四、浏览器显示内容
- 合成线程构建出合成帧，合成帧会被发送给浏览器进程然后再发送给GPU。
- 无论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，一张图片停留的时间约为 16.7 ms。
- 而每次更新的图片都来自显卡的**前缓冲区**。
- 而**显卡（包含 GPU、显存）**接收到浏览器进程传来的页面后，会合成相应的图像，并将图像保存到**后缓冲区**，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。
- 当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像**传送给显卡就会不及时**，而**显示器**还是以不变的**频率刷新**，因此会出现卡顿，也就是明显的掉帧现象
  
## 十五、初始化加载完成
当导航提交完成后，渲染进程开始加载资源及渲染页面，当页面渲染完成后（页面及内部的iframe都触发了onload事件），会向浏览器进程发送IPC消息，告知浏览器进程，这个时候UI thread会停止展示tab中的加载中图标。

