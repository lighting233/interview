# 从输入 url 到页面渲染

## 一、用户输入 url 开始进行 url 解析
1. **浏览器进程**中的UI thread线程负责用户界面的交互，控制浏览器上的按钮及输入框。当你在地址栏输入 URL 时，UI thread责捕捉这个输入。会判断输入的内容是搜索关键词（search query）还是URL。
2. 按下回车键后，主进程解析 URL，管理标签页的创建和切换，以及启动相应的渲染进程来加载网页。

-  **输入搜索关键词：** 地址栏会使⽤浏览器默认的搜索引擎，来合成新的带搜索关键字的URL ==（关键字需要进行encodeURIComponent处理）==
- **输入 url：** 地址栏会根据规则，给这段内容加上协议，合成为完整的URL；

## 二、浏览器进程通过进程间通信（IPC）把url请求发送给⽹络进程；


## 三、是否有强缓存，是否命中协商缓存，没有缓存则发起 http请求
即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。

## 四、进行DNS解析、是否有 DNS 缓存、没有发起递归解析，获取 ip 地址后发起请求

## 五、建立 TCP 连接

## 六、发送 http 请求
1. 三次握手 + tls握手
2. 四次挥手

## 七、读取响应
1. 网络进程接收到服务器的响应后，开始解析HTTP响应报文，然后根据响应头中的`Content-Type`字段来确定响应主体的**媒体类型**（MIME Type）。
2. 如果媒体类型是一个`HTML`文件，则将响应数据交给**渲染进程**（renderer process）来进行下一步的工作，如果是 `zip` 文件或者其它文件，会把相关数据传输给**下载管理器**。
3. 与此同时，浏览器会进行 Safe Browsing 安全检查，如果域名或者请求内容匹配到已知的恶意站点，网络进程会展示一个警告页。
4. 除此之外，网络进程还会做 CORB（Cross Origin Read Blocking）检查来确定那些敏感的跨站数据不会被发送至渲染进程。

## 八、查找渲染进程
- 各种检查完毕以后，网络进程确信浏览器可以导航到请求网页，网络进程会通知浏览器进程的 UI thread 数据已经准备好，UI thread 会查找到一个 renderer process 进行网页的渲染。
- 浏览器为了对查找渲染进程这一步骤进行优化，考虑到网络请求获取响应需要时间，所以导航开始时，浏览器已经预先查找和启动了一个渲染进程，如果中间步骤一切顺利，当网络进程接收到数据时，渲染进程已经准备好了，但是如果遇到重定向，这个准备好的渲染进程也许就不可用了，这个时候会重新启动一个渲染进程。
- 浏览器进程检查当前url是否与之前打开了渲染进程的⻚⾯的根域名相同，如果相同，则复⽤原来的进程，如果不同，则开启新的渲染进程


## 九、提交导航
- 到了这一步，数据和渲染进程都准备好了，Browser Process 会向 Renderer Process 发送IPC消息来确认导航，此时，网络进程将准备好的数据发送给渲染进程，渲染进程接收到数据之后，又发送IPC消息给浏览器进程，告诉浏览器进程导航已经提交了，页面开始加载。
- 这个时候导航栏会更新，安全指示符更新（地址前面的小锁），访问历史列表（history tab）更新，即可以通过前进后退来切换该页面。

## 十、解析 html 过程

### **1.解析HTML构建DOM树**
- 边解析边构建
```
Bytes → characters → tokens → nodes → DOM
```
1. **Conversion转换**：浏览器将获得的HTML内容（**Bytes**）基于他的编码转换为**单个字符**
2. **Tokenizing分词**：浏览器**按照HTML规范标准**将这些**字符**转换为不同的标记**token**。每个token都有自己独特的含义以及规则集
3. **Lexing词法分析**：分词的结果是得到一堆的token，此时把他们转换为**node对象**，这些对象分别定义他们的**属性和规则**
   - **注意**：渲染引擎还有⼀个安全检查模块叫 XSSAuditor，是⽤来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，⽐如是否引⽤了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内XSSAuditor 会对该脚本或者下载任务进⾏拦截。 
4. **DOM构建**：因为HTML标记定义的就是不同标签之间的关系，这个关系就像是一个树形结构一样
5. **⾸次解析HTML时渲染进程会开启⼀个预解析线程**：在构建DOM的过程中，**会解析到**图片、CSS、JavaScript脚本等资源，这些资源是需要从网络或者缓存中获取的，主线程在构建DOM过程中如果遇到了这些资源，逐一发起请求去获取，而为了提升效率，浏览器也会运行预加载扫描（preload scanner）程序，如果HTML中存在img、link等标签，预加载扫描程序会把这些请求传递给网络进程进行资源下载。
但是不能对优先级进行控制，例如 css 引用字体，要等，css 下载完后再下载字体，造成页面闪烁。或者首屏不需要的 css 也提前下载，阻塞首屏渲染。这时就需要 preload
### **2.构建CSSOM并进行样式计算**
在计算完样式之后，所有的样式值会被挂在到`window.getComputedStyle`当中，也就是可以通过JS来获取计算后的样式
#### 需要解析的三类元素
1. 通过 link 引用的外部 CSS 文件
2. `<style>`标签内的样式
3. 元素的 style 属性内嵌的 CSS
#### 1.格式化样式表
```
Bytes → characters → tokens → nodes → CSSOM
```
在控制台打印document.styleSheets，这就是解析出的样式表
#### 2.标准化样式属性
有一些 CSS 样式的数值并不容易被渲染引擎所理解，因此需要在计算样式之前将它们标准化，⽐如将em转换为px，color转换为rgb等等。
#### 3.计算每个节点的具体样式
样式已经被**格式化**和**标准化**,接下来就可以计算**每个节点**的具体**样式信息**了.
1. **继承**:每个子节点都会默认继承父节点的样式属性，如果父节点中没有找到，就会采用浏览器默认样式，也叫UserAgent样式
2. **层叠**: 也就是最终的样式取决于各个属性共同作用的效果

## 十一、渲染过程
==在CSS属性改变时，重渲染会分为“**回流**”、“**重绘**”和“**直接合成**”三种情况，分别对应从“**布局定位**”/“**图层绘制**”/“**合成显示**”==
1. **回流（又叫重排**）：元素位置、大小发生变化导致其他节点联动，需要重新计算布局；
2. **重绘**：修改了一些不影响布局的属性，比如颜色；
3. **直接合成**：合成层的transform、opacity修改，只需要将多个图层再次合并，而后生成位图，最终展示到屏幕上；
### **1.生成布局树(Layout Tree)** 布局（Layout）
- 现在已经生成了DOM树和DOM样式，接下来要做的就是通过浏览器的布局系统**确定元素的位置**，也就是要生成一棵布局树(Layout Tree)。布局（Layout）其实就是找到所有元素的**几何关系**的过程。
- 一般来说，布局树和DOM树相对应的，但不是严格意义上的一一对应.如`head`这种不可见的标签或者`display: none`等.
- Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为回流 **（Reflow）**

1. 遍历生成的 DOM 树节点，并把他们添加到布局树中。
2. 计算布局树节点的坐标位置。

### **2.绘制过程 （Paint）**
这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为重绘 **（Repaint）**
#### 1.建立图层树-合成层
- 生成布局树后还需要考虑3D动画如何呈现出变换效果，当元素含有层叠上下文时如何控制显示和隐藏等等
- 为了解决如上所述的问题，浏览器在构建完布局树之后，还会对特定的节点进行分层，构建一棵图层树 **(Layer Tree)**。
##### 1.生成渲染层的条件
1. 创建层叠上下文的节点
2. 此外需要剪裁的元素也会形成一个渲染层，也就是overflow不是visible的元素。比如一个div，你只给他设置 100 * 100 像素的大小，而你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条会被单独提升为一个图层。
##### 2.合成层
在开发者工具中看到的不是渲染层，而是下面要讲的合成层，只有一些**特殊的渲染层**才会被提升为合成层，通常来说有这些情况：
1. 产生 滚动条 的元素
2. 滚动条 单独生成图层
3. 产生 滚动的内容 单独生成图层
4. HTML 根元素
5. video 元素
6. canvas 元素
7. iframe 标签
8. 拥有 CSS3 动画 的元素，对 opacity | transform | fliter 应用了过渡和动画（transition/animation）
9. position：fixed 的定位元素
10. transform:3D变换：translate3d，translateZ
11. 拥有 CSS will-change 属性的元素  opacity、transform、transform-style、perspective、filter、backdrop-filter 
可以看出，上面这些条件属于生成渲染层的“加强版”，也就是说形成合成层的条件要更苛刻。

##### 3.利用合成层优化
- 之所以叫硬件加速，就是因为合成层会交给GPU（显卡）去处理，在硬件层面上开外挂，比在主线程（CPU）上效率更高。
- 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
**方案：**
1. 避免重排/重绘，直接进行合成，合成层的transform 和 opacity的修改都是直接进入合成阶段的；比如可以使用transform:translate代替left/top修改元素的位置；使用transform:scale代替宽度、高度的修改；
2. 注意隐式合成，给合成层一个较大的z-index值，虽然大部分浏览器已经实现了层压缩的能力，但是依旧有无法处理的情况，最好的办法就是一开始就避免层爆炸
3. 减小合成层占用的内存，合成层的最大问题就是占用内存较多，而内存的占用和元素的尺寸是成正比的，如果要实现一个100X100的元素，可以给宽高都设置为10px，再使用transform:scale(10)放大10倍，这样占用的内存只有直接设置的1/100
4. 使用visibility不触发重排，但是依然重绘。直接使用opacity即触发重绘，又触发重排（GPU底层设计）。opacity配合图层使用，既不触发重绘也不触发重排。原因：
透明度的改变时候，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。不过这个前提是这个被修改opacity本身必须是一个图层
**缺点：**
1. 绘制的图层必须传输到 GPU，这些层的数量和大小达到一定量级后，可能会导致传输非常慢，进而导致一些低端和中端设备上出现闪烁。
2. 隐式合成容易产生过量的合成层，每个合成层都占用额外的内存，而内存是移动设备上的宝贵资源，过多使用内存可能会导致浏览器崩溃，让性能优化适得其反
##### 4.隐式合成
- 简单来说就是层叠等级低的节点被提升为单独的图层之后，那么所有层叠等级比它高的节点都会成为一个单独的图层。
- 如果在一个大型应用中，当一个z-index比较低的元素被提升为单独图层之后，层叠在它上面的的元素统统都会被提升为单独的图层，可能会增加上千个图层，大大增加内存的压力，甚至直接让页面崩溃。这就是**层爆炸的原理**。
##### 5.层爆炸
- 隐式合成产生了很多预期外的合成层——页面中所有 z-index 高于它的节点全部被提升，这些合成层都是相当消耗内存和GPU的。所以带给我们的启示是给合成层一个大的z-index值，避免出现隐式合成。
- 由于 animation transform 的特殊性（动态交叠不确定），隐式合成在不需要交叠的情况下也能发生，就导致了页面中所有 z-index 高于它的节点所对应的渲染层全部提升为合成层，最终让这个页面整整产生了几千个合成层。

##### 6.层压缩
- 如果多个渲染层同一个合成层重叠时，这些渲染层会被压缩到一个 GraphicsLayer 中，以防止由于重叠原因导致可能出现的“层爆炸”。
- 当然了，浏览器的自动层压缩并不是万能的，有很多特定情况下，浏览器是无法进行层压缩的


## 初始化加载完成
当导航提交完成后，渲染进程开始加载资源及渲染页面，当页面渲染完成后（页面及内部的iframe都触发了onload事件），会向浏览器进程发送IPC消息，告知浏览器进程，这个时候UI thread会停止展示tab中的加载中图标。

