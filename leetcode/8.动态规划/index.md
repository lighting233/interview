## 动态规划

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

## 背包理论基础一
- 01 背包就是有 n 种物品，每种只有 1 个
- `dp[i][j]` 表示[0,i]之间的物品任取，装进 j 大小的背包，所能收获的最大价值
- 容量为 j 时，**不放物品** i 的最大价值`dp[i - 1][j]`；**放物品**i 的最大价值为`dp[i-1][j - weight[i]]+value[i]`
- `dp[i][j] = Math.max(dp[i - 1][j],dp[i - 1][j - weight[i]]+value[i])`

```js
// m为物品的个数，n为背包的容量
int m = weight.length, n = bagWeight;
// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况
int[][] dp = new int[m + 1][n + 1];
for (int i = 1; i <= m; i++) { // 遍历物品
    for (int j = 0; j <= n; j++) { // 遍历背包
        if (j < weight[i - 1]) {
            dp[i][j] = dp[i - 1][j];
        } else {
            // 注意这里跟01背包只有下面一个下标不同，那就是“放i”这个选择，因为是可以重复放的，所以是dp[i]
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i - 1]] + value[i - 1]);
        }
    }
}
```
## 背包理论基础二
- `dp[j]`容量为 j 的背包所能收货的最大价值
- `dp[j] = Math.max(dp[j],dp [j - weight[i]]+value[i])`
- 倒序遍历，用的是一层表示两层，下一层只由上层推导而来，先把前边改变了，就影响了后边了
- 正序遍历背包，相当于前一个背包容量装了一个物品，遍历到当前又依赖前边的结果又加了一遍当前物品，所以加了多个物品，变成了完全背包
## 完全背包
完全背包就是有 n 种物品，每种有 n 个 
二维数组开始讲比较好理解，二维数组解法01背包是继承上层左侧状态，完全背包是继承本层左侧状态。所以压缩成一维数组后是正向遍历
之所以可以先遍历物品再遍历背包，是因为从递推公式看，可以从左上推出来；先遍历背包，再遍历物品，是可以每列从上到下推出来

对于每个物品来说有两种选择，不选取或选取。所以dp[i][j]可以从这两类选择中推导出：
1. 不选取物品i：
    由`dp[i - 1][j]`推出，即背包容量为j，里面不放物品i的最大价值，即`dp[i][j] = dp[i - 1][j]`。
2. 选取物品i：
    **由`dp[i][j - weight[i]]`推出，注意这里和01背包的区别，因为可以重复放物品i，所以是`dp[i][j - weight[i]]`**，表示背包容量为`j - weight[i]`的时候任取物品i的最大价值，那么`dp[i][j - weight[i]] + value[i]`（物品i的价值） ，就是背包放物品i得到的最大价值，即`dp[i][j] = dp[i][j - weight[i]] + value[i]`。

所以，递推公式为：
如果物品i的重量大于背包容量j时，背包放不下，就不能选择物品i，`dp[i][j] = dp[i - 1][j]`；
如果物品i的重量小于等于背包容量j时，`dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + value[i])`。
```java
// m为物品的个数，n为背包的容量
int m = weight.length, n = bagWeight;
// m + 1是考虑没有任何物品的情况，n + 1是考虑背包容量为0的情况
int[][] dp = new int[m + 1][n + 1];
for (int i = 1; i <= m; i++) { // 遍历物品
    for (int j = 0; j <= n; j++) { // 遍历背包
        if (j < weight[i - 1]) {
            dp[i][j] = dp[i - 1][j];
        } else {
            // 注意这里跟01背包只有下面一个下标不同，那就是“放i”这个选择，因为是可以重复放的，所以是dp[i]
            dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - weight[i]] + value[i]);
        }
    }
}
```
## 多重背包
多重背包就是有 n 种物品，每种物品个数各不相同