# 一、24年8月17日 第一次学习
## [lteetcode-347-前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/description/)
[优先级队列正式登场！大顶堆、小顶堆该怎么用](https://www.bilibili.com/video/BV1Xg41167Lz?spm_id_from=333.788.videopod.sections&vd_source=78435c3cefd4783245d9d16d09d19859)
[10分钟看懂必考的数据结构——堆](https://www.bilibili.com/video/BV1AF411G7cA/?spm_id_from=333.788.top_right_bar_window_custom_collection.content.click&vd_source=78435c3cefd4783245d9d16d09d19859)

### 思路
1. 使用 map 结构能构造一个 key 记录元素值，val 记录出现频率的结构(直接对map都数据进行快排是nlogN)
2. 堆最擅长处理一堆元素中找出前几个最大的或最小的
3. 只需要维护 k 个长度的堆，保存出现频率最高的，其余的出现品频率不关心
4. 如果用大顶堆，长度 k 不变，每次 push 进来一个元素，堆顶都要出栈，则维护不了堆里都是最大值，所以使用小顶堆




### 完全二叉树
- 完全二叉树只允许最后一行不为满
- 且最后一行必须从左往右排序
- 最后一行元素之间不可以有间隔
### 堆结构
1. 堆必须是一个完全二叉树
2. 堆序性: 堆用一个一维数组来描述,层序遍历后,为每个元素排号,然后把对应的元素依次放入对应的下标
   1. 大顶堆：每个根节点都必须大于他的子节点元素
   2. 小顶堆：每个父节点元素都必须小于他的子节点元素
3. 堆的存储：层序遍历依次编号，存入数组，因为是完全二叉树，所以数组下标和编号是一一对应的
   1. 节点下标为 i
   2. 左子节点下标为 2i+1
   3. 右子节点下标为 2i+2
   
#### 操作
1. 下滤：大顶堆为例，假如堆顶不符合堆序性，则这个节点和他最大的子节点换位置 log n (不论上滤还是下滤都是有一个元素不符合堆序性)
2. 上滤：大顶堆为例，假如最后一个元素不符合堆序性，则该元素和他的父元素交换，直到无法上移为止，这个操作主要是新元素插入堆中 log n

#### 建堆
1. 自顶向下： 将数组(一个乱序数组构建一个新的堆)中元素依次插入**新堆**的最后一位，依次进行上滤操作 n*log n
2. 自下而上：先将数组(一个乱序数组)即元素组成的**无序堆**，然后开始从倒数第二排开始下滤操作 n，从后向前 log n

#### 应用
1. 优先队列：弹出最小元素，小顶堆实现。弹出堆顶元素，将最后一个元素放到根节点，然后进行下滤操作。弹出操作的复杂度为logN;插入元素就使用上滤操作，上滤操作本来就是插入堆的操作 logN
2. 堆排序：使用大顶堆，(堆顶元素和堆尾元素交换,堆顶元素再下滤)排序的结果会放到堆空缺的单元里，组成一个升序数组   `nlogN`  (用大顶堆排序,排序后数组是正序的, 小顶堆是倒序)
