## 1.js 中二进制的位运算都是如何操作的？

在JavaScript中，二进制的位运算是对数字的二进制表示形式进行操作的。这些操作在底层处理时会将数字转换为32位有符号整数，然后执行相应的位操作。以下是JavaScript中常见的位运算符及其操作方式：

### 1. **按位与（AND）`&`**
按位与操作会对每一对对应的二进制位执行逻辑与运算（即`1 & 1 = 1`，其余情况结果为`0`）。

```javascript
5 & 3  // 结果是 1
```

解释：
- `5`的二进制表示为`0101`
- `3`的二进制表示为`0011`
- `5 & 3` 结果为`0001`，即十进制的`1`

### 2. **按位或（OR）`|`**
按位或操作会对每一对对应的二进制位执行逻辑或运算（即`0 | 0 = 0`，其余情况结果为`1`）。

```javascript
5 | 3  // 结果是 7
```

解释：
- `5`的二进制表示为`0101`
- `3`的二进制表示为`0011`
- `5 | 3` 结果为`0111`，即十进制的`7`

### 3. **按位异或（XOR）`^`**
按位异或操作会对每一对对应的二进制位执行异或运算（即`相同为0，不同为1`）。

```javascript
5 ^ 3  // 结果是 6
```

解释：
- `5`的二进制表示为`0101`
- `3`的二进制表示为`0011`
- `5 ^ 3` 结果为`0110`，即十进制的`6`

### 4. **按位非（NOT）`~`**
按位非操作会将二进制中的每一位取反（即`0`变为`1`，`1`变为`0`）。

```javascript
~5  // 结果是 -6
```

解释：
- `5`的二进制表示为`0101`
- `~5` 结果为`1010`，即十进制的`-6`（注意：按位非操作会返回数字的补码形式）

### 5. **左移（Left Shift）`<<`**
左移操作会将数字的二进制位向左移动指定的位数，右边用`0`填充。每左移一位，相当于乘以2。

```javascript
5 << 1  // 结果是 10
2 << 1 // 4
2 << 2 // 8
2 << 3 // 16
```

解释：
- `5`的二进制表示为`0101`
- 左移1位得到`1010`，即十进制的`10`

### 6. **右移（Signed Right Shift）`>>`**
右移操作会将数字的二进制位向右移动指定的位数，左边的位用符号位填充。如果数字是正数，则用`0`填充；如果是负数，则用`1`填充。

```javascript
5 >> 1  // 结果是 2
```

解释：
- `5`的二进制表示为`0101`
- 右移1位得到`0010`，即十进制的`2`

### 7. **无符号右移（Unsigned Right Shift）`>>>`**
无符号右移操作会将数字的二进制位向右移动指定的位数，左边用`0`填充。与`>>`不同的是，无符号右移总是用`0`填充左边的位。

```javascript
-5 >>> 1  // 结果是 2147483645
```

解释：
- `-5`的二进制表示（32位）为`11111111111111111111111111111011`
- 无符号右移1位得到`01111111111111111111111111111101`，即十进制的`2147483645`

### 总结

- **按位与（`&`）**：对二进制的每一位执行`与`运算。
- **按位或（`|`）**：对二进制的每一位执行`或`运算。
- **按位异或（`^`）**：对二进制的每一位执行`异或`运算。
- **按位非（`~`）**：对二进制的每一位取反。
- **左移（`<<`）**：将二进制位向左移动，右边用`0`填充。
- **右移（`>>`）**：将二进制位向右移动，符号位保持不变。
- **无符号右移（`>>>`）**：将二进制位向右移动，左边用`0`填充。

这些位运算通常用于性能优化、低级别的二进制操作或某些特定的算法中。

---

## 2.在 js 中有浮点数运算不正确的时候，比如 0.1 + 0.2 不等于 0.3 这是什么原因，要怎么解决？
- 首先，十进制的0.1和0.2会转换成二进制的，但是由于浮点数用二进制表示是无穷的
- 64位双精度浮点数的小数部分最多支持53位二进制，多余的二进制数字被截断，所以两者相加之后的二进制之和
- 将截断之后的二进制数字再转换为十进制，就成了0.30000000000000004，所以在计算时产生了误差
### 解决办法
1. Math.js、decimal.js、big.js
2. 在 Javascript 中，大于9007199254740991的整数精度同样存在问题,
```js
console.log(19571992547450991); //=> 19571992547450990
console.log(19571992547450991===19571992547450992); //=> true
```

在 JavaScript 中，所有数字（除了 `BigInt`）都是使用 **双精度浮点数**（IEEE 754 标准的 64 位浮点数）表示的。这种格式将 64 位分为三个部分：

1. **1 位符号位**：表示正负数（0 为正数，1 为负数）。
2. **11 位指数位**：用于表示数字的规模（数值的范围），使用偏移量形式（exponent bias）编码。
3. **52 位有效位（尾数位）**：用于表示数字的有效精度（即数字的具体细节部分）。

接下来我们具体探讨 **指数位** 的作用以及整个表示方式，并通过一个例子说明如何存储一个数。

### 指数位的作用

指数位的主要作用是用来表示数值的“范围”或数量级。在科学计数法中，我们可以将任意一个浮点数表示为：

\[
N = M \times 2^E
\]

其中：
- \( M \) 是尾数（也称为**有效数字**）。
- \( E \) 是指数。

在 64 位浮点数中，**11 位的指数位**使用偏移量（`bias`）的形式表示指数。偏移量是 1023，也就是说，实际存储的指数值是经过加上 1023 偏移量之后的值。

\[
\text{实际指数} = \text{指数位值} - 1023
\]

因此，指数位可以表示的值范围是：

- **最小值**：0 - 1023 = -1023
- **最大值**：2047 - 1023 = 1024

### 具体的浮点数表示例子

让我们以具体的例子说明一个数字是如何存储的，比如 `12.375`。

#### 1. 将数字转换为二进制

首先，将 12.375 转换为二进制。

- 整数部分：12 的二进制是 `1100`。
- 小数部分：0.375 转换为二进制是 `0.011`。

因此，`12.375` 的二进制表示为：

\[
1100.011_2
\]

这可以表示为：

\[
12.375 = 1.100011 \times 2^3
\]

其中，`1.100011` 是尾数 \( M \)，`2^3` 中的 3 是指数 \( E \)。

#### 2. 编码符号位、指数位和尾数位

接下来我们将 `12.375` 按照 IEEE 754 标准存储。

##### 符号位：
- 由于 `12.375` 是正数，符号位为 `0`。

##### 指数位：
- 实际指数 \( E = 3 \)。
- 使用偏移量 1023 表示，因此存储的指数为 \( 3 + 1023 = 1026 \)。
- 1026 的二进制表示为 `10000000010`，这是 11 位的指数。

##### 尾数位：
- 尾数是 `1.100011`，但存储时省略 `1`，只存储小数部分 `100011`。
- 尾数需要填充到 52 位，因此表示为：

\[
1000110000000000000000000000000000000000000000000000
\]

#### 3. 最终表示

因此，`12.375` 的 IEEE 754 64 位表示如下：

- **符号位**：`0`
- **指数位**：`10000000010`
- **尾数位**：`1000110000000000000000000000000000000000000000000000`

最终存储在内存中的 64 位二进制数是：

```
0 10000000010 1000110000000000000000000000000000000000000000000000
```

### 小结

在这个例子中：
- **符号位**：`0` 表示正数。
- **指数位**：`10000000010`，这是偏移量为 1023 的指数，表示实际的指数为 3。
- **尾数位**：`100011...`，这是二进制的小数部分，用于精确表示数值。

### 总结

- **符号位**：表示正负数。
- **指数位**：控制数值的规模或范围，使用偏移量（`bias`）表示。
- **尾数位**：存储数值的精度。

这种格式可以表示从极小的浮点数到极大的浮点数，同时保持相对较高的精度。

指数位的偏移量选择 **1023** 而不是 **1024**，是由于**指数位的表示方式**和**IEEE 754 标准的结构设计**决定的。下面详细解释原因和它对表示范围的影响。

---
### 1. **为什么选择偏移量 1023 而不是 1024？**

在 IEEE 754 标准中，11 位的指数位可以表示 **0 到 2047** 之间的无符号整数。而指数位采用的是**偏移量（biased exponent）**的编码方式，用来支持正负指数。为了保证正负指数均衡，标准选择了 **1023** 作为偏移量（也称为 `bias`），原因如下：

- 偏移量 `1023` 是 11 位指数的中间值，能够均衡表示负指数和正指数。
- 这使得：
  - 存储的指数值为 `0` 时，实际的指数是 `-1023`（`0 - 1023 = -1023`）。
  - 存储的指数值为 `1023` 时，实际的指数是 `0`（`1023 - 1023 = 0`）。
  - 存储的指数值为 `2047` 时，实际的指数是特殊编码，用于表示无穷大（Infinity）或 NaN，而不是一个有效的数值。

如果偏移量是 **1024**，则会导致无法对称表示正负指数。例如，偏移量为 1024 时：

- 存储的指数值为 `0` 时，实际指数将变为 `-1024`（`0 - 1024 = -1024`）。
- 存储的指数值为 `2047` 时，实际指数则会达到 `1023`（`2047 - 1024 = 1023`）。

但是，IEEE 754 标准中需要将指数值 `2047` 保留为特殊用途（如表示无穷大和 NaN），因此无法使用到实际指数值 `1023`。为了保持对称性，选择了 **1023** 作为偏移量。

### 2. **指数范围解释：为什么是 `-1023` 到 `1023` 而不是 `-1024` 到 `1024`**

双精度浮点数的指数位是 11 位，因此可以表示的范围是 **0 到 2047**（2^11 - 1 = 2047）。其中：
- **值为 0** 的指数位用于表示**非规格化数**（subnormal numbers，或称 denormals）。
- **值为 2047** 的指数位用于表示**特殊值**，如无穷大（`Infinity`）或 NaN。

实际的指数值通过以下公式计算：

\[
\text{实际指数} = \text{指数位值} - 1023
\]

由于偏移量是 1023，因此指数位 `0` 表示的实际指数为 `-1023`，而指数位 `2046` 表示的实际指数为 `1023`（`2046 - 1023 = 1023`）。

注意：
- **指数位值 2047**：用于表示特殊值（`Infinity` 或 NaN），不代表实际的数值。
- **指数位值 0**：用于表示非规格化数（即指数为 -1022，尾数没有隐含的 `1` 位）。

因此，指数的有效范围是从 **`-1023` 到 `1023`**。

### 3. **指数范围为什么不是 `-1024` 到 `1024`**

由于指数位 `2047` 被保留用于表示特殊值（如无穷大和 NaN），它并不表示实际数值。这意味着最大有效的指数位是 `2046`，而最小的指数位是 `0`，对应的实际指数范围是：

- 最小实际指数：`0 - 1023 = -1023`
- 最大实际指数：`2046 - 1023 = 1023`

**指数位 0** 还被用于表示非规格化数，因此实际指数值从 **`-1023`** 到 **`1023`**，而不是 `-1024` 到 `1024`。

### 4. **指数位和范围的总结**

- **11 位指数位** 可以表示的值范围是 `0` 到 `2047`。
- 偏移量是 **1023**，使得指数位表示的范围是：
  - **指数位 0** 对应的实际指数是 `-1023`。
  - **指数位 1023** 对应的实际指数是 `0`。
  - **指数位 2046** 对应的实际指数是 `1023`。
  - **指数位 2047** 被保留用于表示特殊值（`Infinity` 和 `NaN`）。

### 5. **为什么指数范围如此设计？**

这个设计主要是为了达到以下目标：
- 保留指数位的极大值（`2047`）作为特殊值，不用于表示实际数值。
- 保证浮点数表示的对称性，能够均衡地表示正数和负数指数。
- 通过偏移量，确保 `0` 能够表示实际指数 `0`，从而简化数值的表示。

### 总结

- **偏移量为 1023** 是为了确保指数范围对称，并为特殊值（如无穷大和 NaN）留出空间。
- 11 位指数位减去偏移量 1023，能够表示的实际指数范围是从 **`-1023` 到 `1023`**，其中极大值 `2047` 用于特殊值，不表示有效的数值。

---

### **为什么尾数位最大能表示 2 的 53 次方减 1，为什么是 53 次方不是 52 次方，为什么要减一**？
在 IEEE 754 双精度浮点数格式中，尾数（又叫有效数字、`mantissa`）的位数是 **52 位**，但是我们常说尾数的有效精度为 **53 位**。这个问题可以通过以下几点来解释：

### 1. **尾数位为什么是 53 位而不是 52 位**

双精度浮点数中，尾数部分只有 **52 位**，但它的**有效精度**是 **53 位**，原因在于 **隐含位（implicit bit）** 的存在。

#### 1.1 隐含的 "1" 位
IEEE 754 标准使用一种称为 **规格化数**（normalized number）的表示方式，这意味着所有非零数都可以表示为：

\[
1.xxx... \times 2^E
\]

其中 `xxx...` 是尾数部分（有效数字）。规格化数的特点是尾数的最高位总是 `1`，因此为了节省存储空间，这个 `1` 不需要显式存储，称为**隐含位**。这样，尽管尾数部分只有 **52 位**，但加上隐含的最高位 `1`，尾数实际上有 **53 位的精度**。

#### 1.2 尾数的组成
- **尾数的存储部分**：52 位，代表小数部分（比如 `0.xxx...`）。
- **隐含位**：由于尾数默认以 `1.xxxx...` 的形式存在，所以最高的 `1` 位是隐含的，加上隐含的 `1`，总共是 **53 位有效数字**。

因此，虽然只有 **52 位存储空间**，但可以表示 **53 位精度的尾数**。

### 2. **为什么尾数可以表示最大为 `2^53 - 1`**

#### 2.1 尾数位的最大值
浮点数的尾数部分表示的是小数，但经过科学计数法形式转换后，它实际上可以视作一个 **53 位的整数**。由于尾数部分有 52 位存储，再加上隐含的最高位 `1`，尾数的最大值可以被表示为：

\[
1.111...111 \times 2^E
\]

其中，`1.111...111` 代表的是一个 **二进制下的 53 位 1**，也就是：

\[
111111...111_2 \quad (共 53 位)
\]

将它转换为十进制，这相当于 `2^53 - 1`，因为：

\[
1.111...111_2 = 2^0 + 2^{-1} + 2^{-2} + \dots + 2^{-52}
\]

如果你把它当作一个 **整数** 来看，这个值相当于：

\[
(1 \cdot 2^{52}) + (1 \cdot 2^{51}) + \dots + (1 \cdot 2^0) = 2^{53} - 1
\]

所以，尾数的最大值实际上是 `2^53 - 1`。

#### 2.2 为什么要减 1？
这个减 1 的原因是因为二进制表示下，**53 位全为 1** 的情况下，其数值为 `2^53 - 1`。也就是说，最大可表示的值不是 `2^53`，而是比它少 1，因为：
- 如果全部 53 位都为 1，转化为十进制正好是 `2^53 - 1`。
- 尾数的最大值是 `1.111...111`（53 个 1），相当于二进制下的最大值，所以减去 1 是为了表达**尾数的最大值不超出这个范围**。

### 3. **尾数为什么有 53 位精度，而不是 52 位？**

简单来说，虽然浮点数尾数部分只存储了 **52 位**，但由于 **规格化数** 的引入，最高的 `1` 位是**隐含的**，不需要显式存储，所以在实际计算中，尾数部分的精度相当于 **53 位**。这使得双精度浮点数能够表示非常高的精度。

### 4. **举例：最大可表示的整数**

最大可表示的整数就是 **53 位有效精度**所能表示的最大值。在 JavaScript 或其他基于 IEEE 754 双精度浮点数的语言中，最大可精确表示的整数是：

\[
2^{53} - 1 = 9007199254740991
\]

这个数在 JavaScript 中对应常量 `Number.MAX_SAFE_INTEGER`，即：

```javascript
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
```

如果超过这个数，再进行精确的整数运算时，浮点数的精度可能会丢失，因为超过 53 位有效数字的部分将无法正确表示。

### 总结

1. **尾数的有效精度是 53 位**，因为有 1 位隐含的 `1`，加上 52 位存储的小数部分。
2. **最大可表示的尾数值是 `2^53 - 1`**，对应的是 53 位全为 1 的二进制数。
3. **为什么减 1**：因为二进制数 `111...111`（53 位 1）在十进制下正好等于 `2^53 - 1`。