## 1.js 中二进制的位运算都是如何操作的？

在JavaScript中，二进制的位运算是对数字的二进制表示形式进行操作的。这些操作在底层处理时会将数字转换为32位有符号整数，然后执行相应的位操作。以下是JavaScript中常见的位运算符及其操作方式：

### 1. **按位与（AND）`&`**
按位与操作会对每一对对应的二进制位执行逻辑与运算（即`1 & 1 = 1`，其余情况结果为`0`）。

```javascript
5 & 3  // 结果是 1
```

解释：
- `5`的二进制表示为`0101`
- `3`的二进制表示为`0011`
- `5 & 3` 结果为`0001`，即十进制的`1`

### 2. **按位或（OR）`|`**
按位或操作会对每一对对应的二进制位执行逻辑或运算（即`0 | 0 = 0`，其余情况结果为`1`）。

```javascript
5 | 3  // 结果是 7
```

解释：
- `5`的二进制表示为`0101`
- `3`的二进制表示为`0011`
- `5 | 3` 结果为`0111`，即十进制的`7`

### 3. **按位异或（XOR）`^`**
按位异或操作会对每一对对应的二进制位执行异或运算（即`相同为0，不同为1`）。

```javascript
5 ^ 3  // 结果是 6
```

解释：
- `5`的二进制表示为`0101`
- `3`的二进制表示为`0011`
- `5 ^ 3` 结果为`0110`，即十进制的`6`

### 4. **按位非（NOT）`~`**
按位非操作会将二进制中的每一位取反（即`0`变为`1`，`1`变为`0`）。

```javascript
~5  // 结果是 -6
```

解释：
- `5`的二进制表示为`0101`
- `~5` 结果为`1010`，即十进制的`-6`（注意：按位非操作会返回数字的补码形式）

### 5. **左移（Left Shift）`<<`**
左移操作会将数字的二进制位向左移动指定的位数，右边用`0`填充。每左移一位，相当于乘以2。

```javascript
5 << 1  // 结果是 10
2 << 1 // 4
2 << 2 // 8
2 << 3 // 16
```

解释：
- `5`的二进制表示为`0101`
- 左移1位得到`1010`，即十进制的`10`

### 6. **右移（Signed Right Shift）`>>`**
右移操作会将数字的二进制位向右移动指定的位数，左边的位用符号位填充。如果数字是正数，则用`0`填充；如果是负数，则用`1`填充。

```javascript
5 >> 1  // 结果是 2
```

解释：
- `5`的二进制表示为`0101`
- 右移1位得到`0010`，即十进制的`2`

### 7. **无符号右移（Unsigned Right Shift）`>>>`**
无符号右移操作会将数字的二进制位向右移动指定的位数，左边用`0`填充。与`>>`不同的是，无符号右移总是用`0`填充左边的位。

```javascript
-5 >>> 1  // 结果是 2147483645
```

解释：
- `-5`的二进制表示（32位）为`11111111111111111111111111111011`
- 无符号右移1位得到`01111111111111111111111111111101`，即十进制的`2147483645`

### 总结

- **按位与（`&`）**：对二进制的每一位执行`与`运算。
- **按位或（`|`）**：对二进制的每一位执行`或`运算。
- **按位异或（`^`）**：对二进制的每一位执行`异或`运算。
- **按位非（`~`）**：对二进制的每一位取反。
- **左移（`<<`）**：将二进制位向左移动，右边用`0`填充。
- **右移（`>>`）**：将二进制位向右移动，符号位保持不变。
- **无符号右移（`>>>`）**：将二进制位向右移动，左边用`0`填充。

这些位运算通常用于性能优化、低级别的二进制操作或某些特定的算法中。

---

## 2.在 js 中有浮点数运算不正确的时候，比如 0.1 + 0.2 不等于 0.3 这是什么原因，要怎么解决？
- 首先，十进制的0.1和0.2会转换成二进制的，但是由于浮点数用二进制表示是无穷的
- 64位双精度浮点数的小数部分最多支持53位二进制，多余的二进制数字被截断，所以两者相加之后的二进制之和
- 将截断之后的二进制数字再转换为十进制，就成了0.30000000000000004，所以在计算时产生了误差
### 解决办法
1. Math.js、decimal.js、big.js
2. 在 Javascript 中，大于9007199254740991的整数精度同样存在问题,
```js
console.log(19571992547450991); //=> 19571992547450990
console.log(19571992547450991===19571992547450992); //=> true
```

在 JavaScript 中，所有数字（除了 `BigInt`）都是使用 **双精度浮点数**（IEEE 754 标准的 64 位浮点数）表示的。这种格式将 64 位分为三个部分：

1. **1 位符号位**：表示正负数（0 为正数，1 为负数）。
2. **11 位指数位**：用于表示数字的规模（数值的范围），使用偏移量形式（exponent bias）编码。
3. **52 位有效位（尾数位）**：用于表示数字的有效精度（即数字的具体细节部分）。

接下来我们具体探讨 **指数位** 的作用以及整个表示方式，并通过一个例子说明如何存储一个数。

### 指数位的作用

指数位的主要作用是用来表示数值的“范围”或数量级。在科学计数法中，我们可以将任意一个浮点数表示为：

\[
N = M \times 2^E
\]

其中：
- \( M \) 是尾数（也称为**有效数字**）。
- \( E \) 是指数。

在 64 位浮点数中，**11 位的指数位**使用偏移量（`bias`）的形式表示指数。偏移量是 1023，也就是说，实际存储的指数值是经过加上 1023 偏移量之后的值。

\[
\text{实际指数} = \text{指数位值} - 1023
\]

因此，指数位可以表示的值范围是：

- **最小值**：0 - 1023 = -1023
- **最大值**：2047 - 1023 = 1024

### 具体的浮点数表示例子

让我们以具体的例子说明一个数字是如何存储的，比如 `12.375`。

#### 1. 将数字转换为二进制

首先，将 12.375 转换为二进制。

- 整数部分：12 的二进制是 `1100`。
- 小数部分：0.375 转换为二进制是 `0.011`。

因此，`12.375` 的二进制表示为：

\[
1100.011_2
\]

这可以表示为：

\[
12.375 = 1.100011 \times 2^3
\]

其中，`1.100011` 是尾数 \( M \)，`2^3` 中的 3 是指数 \( E \)。

#### 2. 编码符号位、指数位和尾数位

接下来我们将 `12.375` 按照 IEEE 754 标准存储。

##### 符号位：
- 由于 `12.375` 是正数，符号位为 `0`。

##### 指数位：
- 实际指数 \( E = 3 \)。
- 使用偏移量 1023 表示，因此存储的指数为 \( 3 + 1023 = 1026 \)。
- 1026 的二进制表示为 `10000000010`，这是 11 位的指数。

##### 尾数位：
- 尾数是 `1.100011`，但存储时省略 `1`，只存储小数部分 `100011`。
- 尾数需要填充到 52 位，因此表示为：

\[
1000110000000000000000000000000000000000000000000000
\]

#### 3. 最终表示

因此，`12.375` 的 IEEE 754 64 位表示如下：

- **符号位**：`0`
- **指数位**：`10000000010`
- **尾数位**：`1000110000000000000000000000000000000000000000000000`

最终存储在内存中的 64 位二进制数是：

```
0 10000000010 1000110000000000000000000000000000000000000000000000
```

### 小结

在这个例子中：
- **符号位**：`0` 表示正数。
- **指数位**：`10000000010`，这是偏移量为 1023 的指数，表示实际的指数为 3。
- **尾数位**：`100011...`，这是二进制的小数部分，用于精确表示数值。

### 总结

- **符号位**：表示正负数。
- **指数位**：控制数值的规模或范围，使用偏移量（`bias`）表示。
- **尾数位**：存储数值的精度。

这种格式可以表示从极小的浮点数到极大的浮点数，同时保持相对较高的精度。

指数位的偏移量选择 **1023** 而不是 **1024**，是由于**指数位的表示方式**和**IEEE 754 标准的结构设计**决定的。下面详细解释原因和它对表示范围的影响。

---
### 1. **指数位如何计算**

在 IEEE 754 双精度浮点数标准中，指数部分是通过 **偏移量（biased exponent）** 的方式来表示的。指数的存储不是直接存储实际的指数值，而是将实际指数加上一个**偏移值**来转换成非负整数，然后存储在 11 位的指数位中。对于双精度浮点数，**偏移量为 1023**。

### 1. **指数如何转换为偏移量表示？**

- IEEE 754 双精度浮点数的指数部分有 **11 位**，所以可以存储的指数范围是 `0` 到 `2047`。
- 实际指数的范围是 `-1023` 到 `+1023`。通过将实际指数加上 **1023**（偏移量），可以得到偏移后的指数。

#### 转换公式：
\[
\text{存储的指数值} = \text{实际指数值} + 1023
\]

#### 反向转换公式：
\[
\text{实际指数值} = \text{存储的指数值} - 1023
\]

### 2. **向右偏移的转换和存储**

假设数值为 `123.5`，它的二进制表示为 `1.1110111 × 2^6`，即实际指数为 `6`。

#### 转换步骤：
1. **实际指数**：6
2. **加上偏移量 1023**：6 + 1023 = 1029
3. **存储的指数值**：1029

因此，指数部分存储的值为 `1029`，即二进制为 `10000000101`（11 位）。这个数值表示浮点数 `123.5` 的指数部分，意味着小数点右移 6 位。

### 3. **向左偏移的转换和存储**

假设数值为 `0.15625`，它的二进制表示为 `1.01 × 2^{-3}`，即实际指数为 `-3`。

#### 转换步骤：
1. **实际指数**：-3
2. **加上偏移量 1023**：-3 + 1023 = 1020
3. **存储的指数值**：1020

因此，指数部分存储的值为 `1020`，即二进制为 `1111111100`（11 位）。这个数值表示浮点数 `0.15625` 的指数部分，意味着小数点左移 3 位。

### 4. **特殊情况**

- **指数位为 2047**（即全部是 `1`）：表示特殊值，如 **无穷大（Infinity）** 或 **NaN（Not a Number）**。
- **指数位为 0**：表示 **非规格化数（Subnormal Numbers）**，这些数的实际指数是 `-1022`，并且尾数没有隐含的 `1`。

### 5. **总结：转换和存储流程**

1. **计算实际指数**：根据小数点的位置调整，确定浮点数的实际指数值。
2. **加上偏移量**：将实际指数加上偏移量 1023，得到存储的指数值。
3. **存储 11 位指数位**：结果是一个 11 位的二进制数，存储在浮点数的指数位中。

通过这种方式，指数可以表示正值和负值，并且能够支持非常大的数和非常小的数。

---

### **为什么尾数位最大能表示 2 的 53 次方减 1，为什么是 53 次方不是 52 次方，为什么要减一**？
在 IEEE 754 双精度浮点数格式中，尾数（又叫有效数字、`mantissa`）的位数是 **52 位**，但是我们常说尾数的有效精度为 **53 位**。这个问题可以通过以下几点来解释：

### 1. **尾数位为什么是 53 位而不是 52 位**

双精度浮点数中，尾数部分只有 **52 位**，但它的**有效精度**是 **53 位**，原因在于 **隐含位（implicit bit）** 的存在。

#### 1.1 隐含的 "1" 位
IEEE 754 标准使用一种称为 **规格化数**（normalized number）的表示方式，这意味着所有非零数都可以表示为：

\[
1.xxx... \times 2^E
\]

其中 `xxx...` 是尾数部分（有效数字）。规格化数的特点是尾数的最高位总是 `1`，因此为了节省存储空间，这个 `1` 不需要显式存储，称为**隐含位**。这样，尽管尾数部分只有 **52 位**，但加上隐含的最高位 `1`，尾数实际上有 **53 位的精度**。

#### 1.2 尾数的组成
- **尾数的存储部分**：52 位，代表小数部分（比如 `0.xxx...`）。
- **隐含位**：由于尾数默认以 `1.xxxx...` 的形式存在，所以最高的 `1` 位是隐含的，加上隐含的 `1`，总共是 **53 位有效数字**。

因此，虽然只有 **52 位存储空间**，但可以表示 **53 位精度的尾数**。

### 2. **为什么尾数可以表示最大为 `2^53 - 1`**

#### 2.1 尾数位的最大值
浮点数的尾数部分表示的是小数，但经过科学计数法形式转换后，它实际上可以视作一个 **53 位的整数**。由于尾数部分有 52 位存储，再加上隐含的最高位 `1`，尾数的最大值可以被表示为：

\[
1.111...111 \times 2^E
\]

其中，`1.111...111` 代表的是一个 **二进制下的 53 位 1**，也就是：

\[
111111...111_2 \quad (共 53 位)
\]

将它转换为十进制，这相当于 `2^53 - 1`，因为：

\[
1.111...111_2 = 2^0 + 2^{-1} + 2^{-2} + \dots + 2^{-52}
\]

如果你把它当作一个 **整数** 来看，这个值相当于：

\[
(1 \cdot 2^{52}) + (1 \cdot 2^{51}) + \dots + (1 \cdot 2^0) = 2^{53} - 1
\]

所以，尾数的最大值实际上是 `2^53 - 1`。

#### 2.2 为什么要减 1？
这个减 1 的原因是因为二进制表示下，**53 位全为 1** 的情况下，其数值为 `2^53 - 1`。也就是说，最大可表示的值不是 `2^53`，而是比它少 1，因为：
- 如果全部 53 位都为 1，转化为十进制正好是 `2^53 - 1`。
- 尾数的最大值是 `1.111...111`（53 个 1），相当于二进制下的最大值，所以减去 1 是为了表达**尾数的最大值不超出这个范围**。

### 3. **尾数为什么有 53 位精度，而不是 52 位？**

简单来说，虽然浮点数尾数部分只存储了 **52 位**，但由于 **规格化数** 的引入，最高的 `1` 位是**隐含的**，不需要显式存储，所以在实际计算中，尾数部分的精度相当于 **53 位**。这使得双精度浮点数能够表示非常高的精度。

### 4. **举例：最大可表示的整数**

最大可表示的整数就是 **53 位有效精度**所能表示的最大值。在 JavaScript 或其他基于 IEEE 754 双精度浮点数的语言中，最大可精确表示的整数是：

\[
2^{53} - 1 = 9007199254740991
\]

这个数在 JavaScript 中对应常量 `Number.MAX_SAFE_INTEGER`，即：

```javascript
console.log(Number.MAX_SAFE_INTEGER); // 9007199254740991
```

如果超过这个数，再进行精确的整数运算时，浮点数的精度可能会丢失，因为超过 53 位有效数字的部分将无法正确表示。

### 总结

1. **尾数的有效精度是 53 位**，因为有 1 位隐含的 `1`，加上 52 位存储的小数部分。
2. **最大可表示的尾数值是 `2^53 - 1`**，对应的是 53 位全为 1 的二进制数。
3. **为什么减 1**：因为二进制数 `111...111`（53 位 1）在十进制下正好等于 `2^53 - 1`。