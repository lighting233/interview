## 1.js的 多层 for 循环中执行 break 会整体返回吗?
在 JavaScript 中，`break` 语句用于退出当前循环。当在多层嵌套的 `for` 循环中使用 `break` 时，它只会退出当前循环，而不会退出所有嵌套的循环。也就是说，`break` 语句只会终止它所处的最内层循环。

### 示例

假设你有以下多层嵌套的 `for` 循环：

```js
for (let i = 0; i < 3; i++) {
    console.log('Outer loop:', i);
    for (let j = 0; j < 3; j++) {
        console.log('  Inner loop:', j);
        if (j === 1) {
            break; // 只会退出内层循环
        }
    }
}
```

**输出结果：**

```
Outer loop: 0
  Inner loop: 0
  Inner loop: 1
Outer loop: 1
  Inner loop: 0
  Inner loop: 1
Outer loop: 2
  Inner loop: 0
  Inner loop: 1
```

在这个示例中，当 `j` 的值为 `1` 时，`break` 语句会退出内层的 `for` 循环，但外层的 `for` 循环会继续执行。每次内层循环退出后，外层循环继续执行，直到完成所有迭代。

### 退出所有层的循环

如果你需要在多层循环中退出所有层的循环，可以使用 `标签`（label）与 `break` 语句一起使用。标签允许你指定要退出的循环层级。

**示例：**

```js
outerLoop: // 标签
for (let i = 0; i < 3; i++) {
    console.log('Outer loop:', i);
    for (let j = 0; j < 3; j++) {
        console.log('  Inner loop:', j);
        if (j === 1) {
            break outerLoop; // 退出所有循环
        }
    }
}
```

**输出结果：**

```
Outer loop: 0
  Inner loop: 0
  Inner loop: 1
```

在这个示例中，当 `j` 的值为 `1` 时，`break outerLoop` 语句会退出 `outerLoop` 标签标记的所有循环，结束整个循环结构。

### 总结

- 使用 `break` 语句时，它只会退出当前的最内层循环。
- 如果需要退出多层嵌套的循环，可以使用标签与 `break` 语句一起，以指定要退出的循环层级。
  
---

## 2.'abc'[0]和'abc'.charAt(0)的区别

在 JavaScript 中，`'abc'[0]` 和 `'abc'.charAt(0)` 都可以用来获取字符串中指定位置的字符，但它们有一些细微的区别。

### `'abc'[0]`
- **语法**: 使用数组索引的方式来访问字符串中的字符。
- **返回值**: 返回指定位置的字符。
- **特性**: 如果索引超出字符串的范围，返回 `undefined`。

#### 示例
```javascript
const str = 'abc';
console.log(str[0]); // 输出: "a"
console.log(str[3]); // 输出: undefined
```

### `'abc'.charAt(0)`
- **语法**: 使用 `charAt` 方法来获取字符串中指定位置的字符。
- **返回值**: 返回指定位置的字符。
- **特性**: 如果索引超出字符串的范围，返回空字符串 `""`。

#### 示例
```javascript
const str = 'abc';
console.log(str.charAt(0)); // 输出: "a"
console.log(str.charAt(3)); // 输出: ""
```

### 对比
- **语法**: `'abc'[0]` 使用数组索引语法，而 `'abc'.charAt(0)` 使用方法调用语法。
- **返回值**: 当索引超出范围时，`'abc'[0]` 返回 `undefined`，而 `'abc'.charAt(0)` 返回空字符串 `""`。
- **兼容性**: `charAt` 方法在所有 JavaScript 环境中都可用，而数组索引访问在早期的 JavaScript 版本（如 ECMAScript 3）中可能不被支持，但在现代浏览器中都可以使用。

### 代码示例
以下是一个示例，展示了这两种方法的不同之处：

```javascript
const str = 'abc';

// 使用数组索引访问字符
const charAtIndex0 = str[0]; // "a"
const charAtIndex3 = str[3]; // undefined

// 使用 charAt 方法访问字符
const charAtMethodIndex0 = str.charAt(0); // "a"
const charAtMethodIndex3 = str.charAt(3); // ""

console.log(`Using array index: ${charAtIndex0}, ${charAtIndex3}`); // 输出: Using array index: a, undefined
console.log(`Using charAt method: ${charAtMethodIndex0}, ${charAtMethodIndex3}`); // 输出: Using charAt method: a, 
```

通过这些示例，你可以看到这两种方法在处理超出范围的索引时的不同行为。

---

## 3.slice
- 不改变原数组，返回新数组
- 不论正负都是左闭右开区间
```ts
let arr = [1, 2, 3, 4, 5];

let newArr1 = arr.slice(1, 4); // [2, 3, 4]
let newArr2 = arr.slice(2);    // [3, 4, 5]
let newArr3 = arr.slice(-3, -1); // [3, 4]
```

---

## 4.Math.random
`Math.random()` 是 JavaScript 中用于生成伪随机数的一个内置方法。它返回一个介于 0（包括 0）和 1（不包括 1）之间的浮点数。这个数是均匀分布的，即每个可能的数值在该范围内出现的概率相等。

#### 基本用法

```javascript
let randomNumber = Math.random();
console.log(randomNumber); // 输出一个介于 0 和 1 之间的随机数，例如 0.234567
```

#### 生成特定范围内的随机数

如果你需要生成介于 `min` 和 `max` 之间的随机数，可以使用以下方法：

```javascript
function getRandomInRange(min, max) {
  return Math.random() * (max - min) + min;
}

// 生成介于 5 和 10 之间的随机数
let randomInRange = getRandomInRange(5, 10);
console.log(randomInRange);
```

#### 生成整数随机数

要生成一个特定范围内的整数随机数，可以结合 `Math.random()` 和 `Math.floor()` 使用：

```javascript
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

// 生成介于 1 和 10 之间的随机整数
let randomInt = getRandomInt(1, 10);
console.log(randomInt);
```

#### 重要说明

- **伪随机性**：`Math.random()` 生成的是伪随机数，基于算法生成的随机数序列，不是真正的随机数。对于大多数应用场景，这种伪随机数足够用了，但对于加密或高安全要求的应用，你可能需要使用更复杂的随机数生成器或加密强度更高的随机数。

- **种子**：`Math.random()` 不允许设置种子值，因此每次运行代码时产生的随机数序列都是不同的。若需要可预测的随机数序列，可以使用第三方库如 `seedrandom`。

---
### js中如何把一个数组中的元素随机排序？
在 JavaScript 中，你可以使用 `Array.prototype.sort()` 方法结合 `Math.random()` 来实现数组元素的随机排序。下面是一个常见的实现方法：

```javascript
function shuffleArray(array) {
  return array.sort(() => Math.random() - 0.5);
}
```

#### 解释：

- `array.sort(() => Math.random() - 0.5)` 使用了一个比较函数。这个比较函数返回一个介于 -0.5 和 0.5 之间的随机值，因此 `sort()` 方法会将数组元素随机排序。

#### 注意事项：

1. **稳定性**：这种方法并不稳定（即相同的输入数组可能得到不同的排序结果），但它是实现随机排序的简单方式。

2. **时间复杂度**：`Array.prototype.sort()` 方法的时间复杂度通常是 O(n log n)，虽然这种方法在实践中表现良好，但如果你需要高质量的洗牌，可以考虑使用更复杂的算法，如 **Fisher-Yates 洗牌算法**。

#### Fisher-Yates 洗牌算法：

Fisher-Yates 算法能确保每个可能的排序结果出现的概率相等，是一个更优雅且高效的解决方案。以下是其实现代码：

```javascript
function shuffleArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]]; // 交换元素
  }
  return array;
}
```

#### 解释：

1. 从数组的最后一个元素开始，随机选择一个索引 `j`，然后将当前元素与 `j` 索引的元素交换位置。

2. 继续向前遍历，直到完成对整个数组的洗牌。

使用 Fisher-Yates 算法可以保证洗牌结果的公平性和效率。

---

### 为什么Math.random生成的随机数是伪随机数？

Math.random()生成的随机数是伪随机数，主要原因可以归纳为以下几点：

1. **算法依赖性**：Math.random()函数是基于一种数学算法来生成随机数的。这种算法通常使用一个初始值（称为种子）来开始生成随机数序列。由于算法是确定性的，即给定相同的种子，它将始终产生相同的随机数序列。因此，这种基于算法生成的随机数在本质上不是真正的随机，而是伪随机。

2. **可预测性**：虽然Math.random()生成的随机数在统计上可能看起来是随机的，但实际上，如果知道算法的内部工作原理以及使用的种子值，理论上是可以预测接下来会生成哪个数字的。这种可预测性使得Math.random()生成的随机数在某些需要高安全性的应用场景中（如加密）是不适用的。

3. **实现差异性**：Math.random()函数的实现依赖于具体的JavaScript引擎（如V8、SpiderMonkey等）。不同的引擎可能会使用不同的算法和种子值来实现这个函数，从而导致生成的随机数序列在质量和可预测性上存在差异。然而，无论哪种实现方式，其生成的随机数都是基于某种确定性算法的，因此都属于伪随机数。

综上所述，Math.random()生成的随机数是伪随机数，主要因为它依赖于确定性的算法来生成随机数序列，并且这种序列在给定相同的种子值时是可预测的。同时，不同的JavaScript引擎实现也可能影响生成随机数的质量和特性。

## 5. Object.is
`NaN === NaN`为 false
`Object.is(NaN,NaN)`为 true

`+0 === -0` // true
`Object.is` //false