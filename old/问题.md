## 1.现在有一个100tb的文件，让你一分钟之内把这个文件遍历出来，怎么做？
要在一分钟内遍历一个100TB的文件是一项非常庞大的任务，因为它涉及到大量的数据读取和处理。在现实情况下，这个任务可能需要使用分布式计算框架和高性能存储系统来处理。
以下是一些可能的方法来处理这个任务：
### 分布式计算
使用分布式计算框架（如Apache Hadoop或Apache Spark）将文件分成多个块，并在多个计算节点上并行处理这些块。这样可以加快遍历的速度。
### 并行处理
如果你有多个计算节点可用，可以将文件分成多个部分，并在每个节点上并行处理这些部分。这样可以同时处理多个部分，提高遍历速度。
### 高性能存储系统
使用高性能的存储系统（如分布式文件系统或对象存储）来存储文件，以便能够快速读取和处理大量数据。
### 数据索引
如果文件中的数据具有某种结构或索引，可以先创建索引，然后使用索引来快速定位和访问文件中的数据。

需要注意的是，以上方法只是一些可能的解决方案，具体的实现取决于你的系统架构和可用资源。在实际操作中，还需要考虑到网络带宽、计算节点的数量和性能、存储系统的性能等因素。
### 什么是计算节点
计算节点是指在分布式计算系统中用于执行计算任务的独立计算机或服务器。在分布式计算环境中，计算节点通常作为集群中的一部分，每个计算节点都有自己的处理器、内存和存储资源。

计算节点的主要功能是执行分布式计算任务的一部分，例如并行处理大规模数据、执行复杂的计算任务或运行分布式应用程序。这些节点通过网络连接在一起，共享任务和数据，并协同工作以完成整个计算任务。

计算节点通常由操作系统和分布式计算软件栈（如Hadoop、Spark等）支持。它们可以在同一台物理机上运行，也可以分布在多台物理机或虚拟机上。通过将计算任务分配给不同的计算节点，并在节点之间共享数据，可以实现更高效的计算和处理能力。

在分布式计算系统中，计算节点的数量和性能对整个计算任务的执行速度和效率有重要影响。增加计算节点的数量可以提高计算能力和并行处理能力，从而加快任务的完成速度。
### 分布式计算和并行处理的区别
-分布式计算：

分布式计算是指将一个计算任务分解成多个子任务，并在多个计算节点上并行执行这些子任务。每个计算节点独立地处理自己分配到的任务，并通过网络进行通信和协调。分布式计算的目标是通过将计算任务分布到多个节点上，以提高整体计算能力和处理速度。
分布式计算通常涉及到多台计算机或服务器，每个计算机都有自己的处理器、内存和存储资源。这些计算机通过网络连接在一起，共享任务和数据，并通过消息传递或共享存储来进行通信和协调。
分布式计算适用于处理大规模数据、复杂的计算任务或需要高可靠性和容错性的应用程序。它可以提供更高的计算能力和处理能力，但也需要额外的网络通信和协调开销。

-并行处理：

并行处理是指将一个计算任务分解成多个子任务，并在同一台计算机或服务器的多个处理单元上同时执行这些子任务。每个处理单元独立地处理自己分配到的任务，但它们可以通过共享内存或消息传递等方式进行通信和协调。并行处理的目标是通过同时执行多个子任务，以提高整体计算能力和处理速度。
并行处理通常发生在单个计算机或服务器上，该计算机具有多个处理单元（如多核处理器或多个计算线程）。这些处理单元可以同时执行不同的任务，从而实现并行处理。
并行处理适用于需要高性能计算的任务，例如图像处理、模拟和科学计算等。它可以利用计算机内部的并行处理能力，提供更高的计算速度和效率。
总结来说，分布式计算是将任务分布到多个计算节点上进行并行处理，而并行处理是在单个计算机或服务器上同时执行多个任务。分布式计算涉及到多个计算机和网络通信，而并行处理则利用单个计算机的多个处理单元。

## 2.进程、线程区别，举个生动的例子？
进程和线程是操作系统中的两个重要概念，它们有以下区别：

### 进程：
进程是操作系统中的一个执行实例，它拥有独立的内存空间、文件描述符和其他系统资源。每个进程都是一个独立的执行环境，可以包含多个线程。
进程是程序的一次执行过程，它具有自己的地址空间和上下文信息。进程之间是相互独立的，一个进程的崩溃不会影响其他进程。
进程之间通过进程间通信（IPC）机制进行通信和数据交换，例如管道、消息队列、共享内存等。
举个例子，可以将进程类比为一个工厂，每个工厂都有自己的资源和独立的生产线。每个工厂可以同时生产不同的产品，但它们之间是相互独立的，一个工厂的停工不会影响其他工厂的运作。
操作系统最小的执行单位

### 线程：
线程是进程内的一个执行单元，它与其他线程共享相同的内存空间和系统资源。一个进程可以包含多个线程，这些线程共享进程的上下文和资源。
线程是进程内的轻量级执行流，它可以独立执行任务，并与其他线程并发执行。线程之间共享进程的内存空间，可以直接访问进程的全局变量和堆内存。
线程之间通过共享内存进行通信和数据交换，但需要注意线程同步和互斥，以避免数据竞争和冲突。
举个例子，可以将线程类比为一个工厂的工人，每个工人都在同一个工厂内工作，共享相同的资源和设备。每个工人可以独立执行自己的任务，但它们之间需要协调和同步，以避免冲突和混乱。

总结来说，进程是一个独立的执行实例，拥有独立的资源和上下文，而线程是进程内的执行单元，共享进程的资源和上下文。进程之间是相互独立的，而线程之间是共享资源和并发执行的。
cpu最小的执行单位

### 多线程：
多线程是指在一个进程内同时运行多个线程的编程模型。在多线程编程中，一个进程可以包含多个线程，每个线程可以独立执行任务，共享进程的内存空间和资源。

多线程编程的优点包括：

并发执行：多个线程可以同时执行不同的任务，从而提高程序的响应速度和效率。
充分利用多核处理器：在多核处理器上，多线程可以充分利用并行处理能力，提高计算性能。
资源共享：多个线程可以共享进程的内存空间和资源，避免了数据复制和通信的开销。
灵活性：多线程编程可以实现任务的分解和并行处理，提供更灵活的程序设计和控制流程。
然而，多线程编程也面临一些挑战和注意事项：

线程同步：多个线程共享相同的资源时，需要进行适当的同步和互斥操作，以避免数据竞争和冲突。
线程安全：在多线程环境下，需要确保共享数据的正确性和一致性，避免出现并发访问导致的错误。
死锁和竞态条件：不正确的线程同步可能导致死锁和竞态条件，需要仔细设计和管理线程间的同步机制。
资源消耗：多线程编程可能增加系统资源的消耗，包括内存、CPU和线程调度等。
在实际的多线程编程中，需要注意线程的创建、启动、同步和销毁等操作，以及合理的线程调度和资源管理。同时，需要注意避免常见的多线程问题，如死锁、竞态条件和内存泄漏等。

总结来说，多线程编程是一种利用多个线程并发执行任务的编程模型，它可以提高程序的响应速度和效率，但也需要注意线程同步、线程安全和资源管理等问题。

## 3.讲讲进程之间通过进程间通信（IPC）机制
进程间通信（IPC）是指不同进程之间进行数据交换和通信的机制。它允许进程之间共享信息、传递消息和同步操作，以实现协作和数据交换。下面是几种常见的进程间通信机制：

管道（Pipe）：管道是一种半双工的通信机制，可以在具有亲缘关系的进程之间进行通信。管道可以是匿名管道（只能在父子进程之间使用）或命名管道（可以在不同进程之间使用）。管道通过一个进程的输出连接到另一个进程的输入，实现数据的单向传输。

共享内存（Shared Memory）：共享内存是一种高效的进程间通信机制，允许多个进程访问同一块内存区域。这样，进程可以直接读写共享内存，避免了数据的复制和传输。共享内存需要通过同步机制（如信号量、互斥锁）来保证数据的一致性和安全性。

消息队列（Message Queue）：消息队列是一种异步的进程间通信机制，通过在进程之间传递消息来实现通信。进程可以将消息发送到队列中，而其他进程可以从队列中接收消息。消息队列可以实现进程之间的解耦和异步通信。

信号量（Semaphore）：信号量是一种用于进程同步的机制，可以用来保护共享资源的访问。进程可以使用信号量来申请和释放资源，以确保多个进程之间的互斥和顺序执行。

套接字（Socket）：套接字是一种用于网络通信的进程间通信机制。它允许不同主机上的进程进行通信，通过网络传输数据。套接字可以实现进程之间的远程通信，例如客户端和服务器之间的通信。

这些进程间通信机制各有优劣，适用于不同的场景和需求。选择适当的 IPC 机制取决于进程之间的关系、通信的性质和要求，以及系统的支持和限制。

### 浏览器中哪些地方用到了消息队列？
浏览器中有几个地方使用了消息队列：

JavaScript 引擎：JavaScript 是浏览器中的脚本语言，它使用事件循环机制来处理异步操作。事件循环基于消息队列，它将异步任务（如定时器、网络请求、事件处理等）放入消息队列中，并在适当的时候执行这些任务。

Web Workers：Web Workers 是一种浏览器提供的多线程机制，允许在后台运行脚本，独立于主线程。Web Workers 使用消息队列来进行主线程和工作线程之间的通信。

Service Workers：Service Workers 是一种在浏览器后台运行的脚本，用于实现离线缓存、推送通知等功能。Service Workers 也使用消息队列来处理主线程和 Service Worker 之间的通信。

总的来说，浏览器中的消息队列用于处理异步操作、多线程通信和后台脚本等场景。

### Service Workers和Web Workers都是什么，有什么区别？
Service Workers 和 Web Workers 都是浏览器提供的用于在后台执行脚本的机制，但它们的用途和工作方式有所不同。

-Service Workers：

Service Workers 是一种独立于网页的 JavaScript 脚本，可以在浏览器后台运行。
它们主要用于实现离线缓存、推送通知、网络代理等功能。
Service Workers 可以拦截和处理网络请求，从而实现离线缓存和离线访问。
它们可以在用户关闭网页后继续运行，并且可以在用户再次打开网页时恢复状态。

-Web Workers：

Web Workers 是一种运行在浏览器中的 JavaScript 脚本，可以在独立的线程中执行。
它们主要用于在后台执行计算密集型任务，以免阻塞主线程的运行。
Web Workers 不能直接访问 DOM，因为它们运行在独立的线程中，与主线程分离。
它们通过消息传递机制与主线程进行通信，可以接收和发送消息。

-区别：

Service Workers 主要用于处理离线缓存、推送通知等与网络相关的功能，而 Web Workers 主要用于在后台执行计算密集型任务。
Service Workers 可以拦截和处理网络请求，而 Web Workers 不能直接访问 DOM。
Service Workers 可以在用户关闭网页后继续运行，而 Web Workers 只能在网页处于活动状态时运行。
Service Workers 使用的是 Service Worker API，而 Web Workers 使用的是 Web Worker API。

## 4.浏览器的核心线程和核心进程有哪些？
浏览器的核心线程和核心进程可以根据具体的浏览器实现和架构而有所不同。以下是一些常见的核心线程和核心进程：

主线程（Main Thread）：主线程是浏览器的核心线程，负责处理用户界面、执行 JavaScript 代码、布局和渲染页面等任务。它与用户界面直接相关，并且负责响应用户输入和更新页面内容。

渲染线程（Rendering Thread）：渲染线程负责将 HTML、CSS 和 JavaScript 转换为用户可见的页面。它执行布局（Layout）和绘制（Paint）操作，并将页面内容呈现到屏幕上。

JavaScript 引擎线程：JavaScript 引擎线程负责解析和执行 JavaScript 代码。它将 JavaScript 代码转换为可执行的指令，并与其他线程协同工作，处理事件和异步操作。

事件线程（Event Thread）：事件线程负责处理用户输入、网络请求、计时器等事件。它将事件添加到事件队列中，并通知相应的线程进行处理。

网络线程（Network Thread）：网络线程负责处理网络请求和响应。它负责与服务器通信，发送请求并接收响应。

GPU 进程（GPU Process）：GPU 进程负责处理页面的 GPU 加速操作，例如 3D 渲染、动画等。它与渲染线程进行通信，将渲染任务发送给 GPU 进行处理。

插件进程（Plugin Process）：插件进程负责加载和运行浏览器插件，例如 Flash、PDF 阅读器等。插件进程与主进程和渲染进程隔离，以提高安全性和稳定性。

需要注意的是，不同浏览器的架构可能会有所不同，因此具体的核心线程和核心进程可能会有所差异。上述列举的是一些常见的线程和进程，用于描述浏览器的基本功能和架构。

## 5.GC垃圾回收

[垃圾回收](https://juejin.cn/post/6981588276356317214)

## 6.jsbrage

## 7.前端监控
[前端监控自研](https://juejin.cn/post/7097157902862909471#heading-9)

## 8.ci/cd

## 9.在 js 中有浮点数运算不正确的时候，比如 0.1 + 0.2 不等于 0.3 这是什么原因，要怎么解决
在 JavaScript 中整数和浮点数都属于 Number 数据类型，所有数字都是以 64 位浮点数形式储存
JavaScript 里的数字是采用 IEEE 754 标准的 64 位双精度浮点数。该规范定义了浮点数的格式，
对于64位的浮点数在内存中的表示，最高的1位是符号位，接着的11位是指数，剩下的52位为有效数字，
因此，JavaScript提供的有效数字最长为53个二进制位（64位浮点的后52位+有效数字第一位的1）。具体：
[js精度问题](https://www.zhihu.com/search?type=content&q=js%20%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97)
在 Javascript 中，整数精度同样存在问题
console.log(19571992547450991); //=> 19571992547450990
console.log(19571992547450991===19571992547450992); //=> true
解决方案：Math.js，decimal.js， big.js
[解决方法](https://zhuanlan.zhihu.com/p/654997463)