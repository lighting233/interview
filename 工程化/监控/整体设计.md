# 整体设计

## 前端SDK架构
- core: 平台无关的一些代码，比如一些公共方法(生成mid方法、格式化)
- 各平台SDK: 各平台继承`core`,web,node,小程序等.每个SDK都是由 **内核+插件** 组成的
  - 每个平台分开打包，每个包的体积会大大缩小；
  - 代码的逻辑更加清晰自恰
- 各平台SDK的core: **公共逻辑**或者**基础逻辑**；比如**数据格式化**和**数据上报**是底下插件都要用到的**公共逻辑**；而**配置初始化**是SDK运行的一个**基础逻辑**；
- 各平台SDK的插件: 插件里是SDK的上层拓展业务，比如说监听js错误、监听promise错误，每一个小功能都是一个插件；
- 内核和插件一起组成了 SDK实例 Instance，最后暴露给客户端使用；

## 插件本身出错怎么办
- 我们对每一个插件模块，都单独的用trycatch包裹起来，然后当抛出错误的时候，进行数据的封装、上报；
- 它实现了：当SDK产生异常时不会影响主业务的流程；
- 当SDK产生异常时进行数据的封装、上报；
- 出现异常后，中止 SDK 的运行，并移除所有的监听；

## SDK 如何实现服务端时间的校对？
- `http`响应头 上有一个字段 `Date`；它的值是服务端发**送资源时**的服务器时间
- 初始化`SDK`的时候，发送一个**简单的请求**给上报服务器，获取返回的 `Date` 值后计算 `Diff`差值 存在本地；
- 我们可以让后端服务在返回的时候，带上 API 请求在后端服务**执行完毕所消耗的时间** `server-timing`，放在响应头里；

## SDK 如何实现会话级别的错误上报去重？
- 错误信息、错误行号、错误列号、错误文件等可能的关键信息的一个集合，这样保证了产生在同一个地方的错误，生成的 错误mid 都是相等的
- 进行hash生成uid
- 客户端针对uid实现同一会话的去重
- 在服务端用以实现相同错误的数据聚合

## SDK 采用什么样的上报策略？
采用 `sendBeacon + xmlHttpRequest` 降级上报的方式，当浏览器不支持 `sendBeacon` 或者 传输的**数据量超过**了 `sendBeacon` 的限制，我们就降级采用 `xmlHttpRequest` 进行上报数据；
### 1.信标（Beacon API）
- sendBeacon 允许你在**页面卸载时发送数据**，确保数据在用户离开页面时被发送。
- 它将数据发送请求标记为**低优先级**，浏览器会在后台处理该请求，不会影响页面的卸载和渲染性能。
- 一般来说，发送的数据量通常建议保持在 `64 KB` 以内，具体限制可能因不同浏览器而异。
```js
const data = new FormData();
data.append('event', 'page unload');
navigator.sendBeacon('/report', data);

const status = window.navigator.sendBeacon(this.options.transportUrl, JSON.stringify(data));
// 如果数据量过大，则本次大数据量用 XMLHttpRequest 上报
if (!status) this.xmlTransport().apply(this, data);

```
### 2.Ajax（XMLHttpRequest 和 fetch）
```js
window.addEventListener('beforeunload', (event) => {
    const data = {
        event: 'page unload',
        timestamp: Date.now(),
        // 其他需要上报的数据
    };

    // 这里使用 XMLHttpRequest 发送数据
    const xhr = new XMLHttpRequest();
    xhr.open('POST', '/report', false); // 设置为同步请求
    xhr.setRequestHeader('Content-Type', 'application/json');
    xhr.send(JSON.stringify(data));

    // 注意：在现代浏览器中，使用同步请求可能会导致警告，且有时会被阻止。
    // 可以考虑在 sendBeacon 可用时优先使用它。
});
```
### 3.Image（GIF、PNG）
- Image 是以`GET`方式请求图片资源的方式，将上报数据附在 URL 上携带到服务端，而URL地址的长度是有一定限制的。
- 规范对 URL 长度并没有要求，但是**浏览器、服务器、代理服务器**都对 URL 长度有要求。有的浏览器要求URL中path部分不超过 2048，这就导致有些请求会发送不完全。
- 至于跨域问题，作为接受数据上报的服务端，允许跨域是理所应当的；
**优势:**
- 实现简单：只需设置 src 属性即可，无需处理复杂的请求参数、回调函数或错误处理逻辑，适合快速上报。
- 更高的兼容性：img 标签在所有浏览器中几乎都能正常工作，而某些浏览器或环境可能对 AJAX 请求有更多限制，尤其是在跨域请求时。
- 轻量级开销：对于小数据量的上报，使用 1x1 像素的透明 GIF 或 PNG 不会消耗太多带宽，减少了性能开销。
- 非阻塞：图片请求是异步的，不会影响页面的渲染性能，用户体验更好。

## 上报时机
- PV、错误、用户自定义行为 都是触发后立即就进行上报；
- 性能数据 需要等待页面加载完成、数据采集完毕后进行上报；
- API请求数据 会进行本地暂存，在数据量达到10条(自拟)时触发一次上报，并且在页面可见性变化、以及页面关闭之前进行上报；
- 如果你还要上报 点击行为 等其余的数据，跟 API请求数据 一样的上报时机；

## 上报优化
- 启用 HTTP2，在 HTTP1 中，每次日志上报请求头都携带了大量的重复数据导致性能浪费。HTTP2头部压缩 采用Huffman Code压缩请求头，能有效减少请求头的大小；
- 服务端可以返回 204 状态码，省去响应体；
- 使用 `requestIdleCallback` ，这是一个较新的 API，它可以插入一个函数，这个函数将在浏览器空闲时期被调用。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如果不支持的话，就使用 settimeout；

## 平台数据如何进行 削峰限流？
前端的削峰限流可以对用户进行削峰（某些用户在初始化时就判断它不进行上报），这样可以避免用户的链路追踪不完整；
```js
if(Math.random()<0.5) return;
```
### 优化方案-流量整型
- **计数器算法**：计数器算法就是**单位时间内**入库数量固定，后面的数据全部丢弃；**缺点**是无法应对恶意用户；
- **漏桶算法**：漏桶算法就是系统以**固有的速率**处理请求，当请求太多超过了桶的容量时，请求就会被丢弃；缺点是漏桶算法对于骤增的流量来说缺乏效率；
- **令牌桶算法**：令牌桶算法就是系统会以恒定的速度往固定容量的桶里放入令牌，当请求需要被处理时就会从桶里取一个令牌，当没有令牌可取的时候就会据拒绝服务；

### 漏桶算法

#### 原理
- 漏桶算法将请求看作水滴，水滴流入一个漏桶，桶的底部有一个孔，水（请求）以固定的速率漏出。
- 不管水滴流入的速度多快，流出桶的速度始终是恒定的。当桶满时，新的水滴将被丢弃。

#### 特点
- **平滑输出**：保证输出速率恒定，避免突发流量。
- **丢弃请求**：当桶满时，新的请求会被丢弃，不会被处理。

#### 适用场景
- 适合用于需要恒定输出速率的场景，如网络带宽控制。

### 令牌桶算法

#### 原理
- 令牌桶算法使用一个桶来存储令牌，令牌以固定的速率生成。当请求到达时，需要消耗一个令牌才能处理请求。
- 桶中有一个最大容量，如果桶满了，则新生成的令牌会被丢弃。请求可以在桶中有令牌时突发处理。

#### 特点
- **突发能力**：允许在短时间内处理突发请求，只要桶中有足够的令牌。
- **平滑输出**：整体上输出速率可以控制，但可以应对突发流量。

#### 适用场景
- 适合用于需要灵活处理突发流量的场景，如API请求限流。

### 主要区别总结

| 特性             | 漏桶算法                      | 令牌桶算法                    |
|------------------|-------------------------------|-------------------------------|
| 输出速率         | 恒定输出速率                 | 输出速率可变，有突发能力      |
| 请求处理方式     | 请求丢弃                     | 请求可以处理，直到没有令牌为止|
| 最大容量         | 固定的桶容量                 | 固定的桶容量                  |
| 适用场景         | 适合恒定速率场景             | 适合突发流量和灵活处理场景    |

这两种算法各有优缺点，选择使用时可以根据具体的需求和场景来决定。

