

## 一、TCP 和 UDP对比
- udp 非面向连接，面向报文封装，不可靠。**一对一，一对多，一对全**
- tcp 面向连接，双向全双工，**一对一**
- 面向字节流封装：
  - **可靠传输**
  - **流量控制**
  - **拥塞控制**
（不误码，不乱序，不重复，不丢失）

### 新版本的 chrome 中同一域名下同时最多能建立几个 tcp 连接？

### TCP首部
- 源端口，目标端口，检验和， 长度， 共 8 字节
- 20-60 字节，源端口，目标端口，检验和，序号，确认号，窗口，rwnd，cwnd， swnd
Dns53
smtp 25
ftp 20、21

#### 拥塞控制 （针对网络承载能力）

3. **快重传**：
   - 要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认
   - 即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。
   - 发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。
#### TCP超时重传时间选择


### TCP可靠传输的实现
### TCP连接建立

#### 能否两次握手，最后一次普通确认报文能否省略？

### TCP链接释放

==LAST-ACK最后确认状态==
，msl 建议为 2min
#### TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？

### TCP保活计时器的作用

==往往这个时间太久了，我们熟知的很多组件都没有开启 keepalive 特性，而是选择在应用层做心跳机制。==
### 什么是 TCP 粘包？
 - 它不保证数据包的边界

### 如何解决 TCP 粘包问题？

#### UDP会不会粘包

#### TCP粘包问题，如果设置长度而当前没收到这么多怎么办？

#### SYN报文什么下会被丟弃？

#### tcp如何提高传输效率