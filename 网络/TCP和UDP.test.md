## 一、TCP 和 UDP对比
- udp 无链接，不可靠，面向报文封装，首部 4 字段 8 字节 ==1 对 1,1 对多，1 对全==
- tcp 面向连接，面向字节流封装==这是他实现可靠传输，流量控制以及拥塞控制的基础==（不丢失，不重复，不误码，不乱序），首部最少 20 字节，最多 60 字节 ==全双工，一对一==

### 新版本的 chrome 中同一域名下同时最多能建立几个 tcp 连接？

### TCP首部
- **数据偏移** 占 4bit 并以 4字节为单位，指出了 tcp 报文首部长度
- **确认**标志位：PSH ==尽快交付应用进程，不必等到缓存填满后交付==，RST ==用来复位 tcp 连接，表示连接出现了异常，必须释放连接，然后重新建立；也可用来拒绝一个非法报文，或拒绝打开一个 tcp 连接,SYN,FIN==，ACK。FIN，SYN，~~UGC~~ ==URG紧急标志位==
- 窗口
- 检验和：防止误码
- - **紧急指针 16bit**
- **选项部分** 有时间戳等等，计算 RTT
- **填充**

#### TCP超时重传时间选择

Tacho
- 慢启动：
  - 初始报文段少，但其数量是指数增加
  - 拥塞窗口cwnd达到==慢开始门限==后开始进入==拥塞避免阶段==
- 拥塞避免：
  - cwnd开始线性增长，直到出现超时重传，慢开始门限变为当前 cwnd 的一半，cwnd 变为 1
  - 不是指避免拥塞，而是指线性增长比较不容易出现拥塞

Reno
- 快重传：
  - 不一定数据包丢失都是因为网络出现拥塞
  - ==所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。==
  - 手段
   1. 要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；
   2. 即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。
   3. 发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。
- 快恢复
  - 收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法
  - 发送方将慢开始门限和拥塞窗口都降为原来的一半，开始进行快恢复
  - 也有的快恢复实现是把快恢复开始时的**拥塞窗口cwnd**值再增大一些，即等于新的**ssthresh + 3**

### 流量控制 （针对双方的缓存空间）

### 拥塞控制 （针对网络承载能力）

- ==有时个别网络报文丢失并非网络发生堵塞，这导致发送方超时重传，误认为网络发生了拥塞，降低了传输效率。==
#### TCP超时重传时间选择

- 不能比 RTT 过小
- 也不能比 RTT 过大
- 超时重传时间 RTO 应该略大于加权平均往返时间 TRRs

### TCP可靠有序传输的实现
TCP 基于字节为单位的滑动窗口来实现可靠传输
- 确认应答机制
- 超时重传机制
### TCP连接建立
解决三个问题
- 确认双方存在
- 协商参数
- 对运输实体资源进行分配

流程
1. 服务器和客户端都在CLOSED 关闭状态
2. 服务端首先创建传输控制块，进入LISTEN 监听状态，称为被动打开连接
3. 客户端创建传输控制块，发送TCP连接请求报文段，进入SYN-SENT 同步已发送状态，称为主动打开连接
   - TCP连接请求报文段首部中：
     - **同步位**SYN被设置为1，表明这是一个TCP连接请求报文段
     - 序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号 **请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号**
4. 服务端如果同意建立连接，发送TCP连接请求**确认**报文段，进入SYN-RCVD 同步已接收状态
   - TCP连接请求确认报文段首部中：
   - **同步位**SYN**同部位**和**确认位**ACK都设置为1，表明这是一个TCP连接请求确认报文段
   - 序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，
   - 确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认 **请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号**

5. TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个**普通**的TCP确认报文段，并进入 ESTABLISHED 连接已连接状态
   - 确认位ACK被设置为1，表明这是一个普通的TCP确认报文段
   - 序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1
   - 确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认 **请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号**


#### 能否两次握手，最后一次普通确认报文能否省略？

### TCP链接释放

1. 双方都在ESTABLISHED 连接已连接状态
2. 客户端发送TCP连接释放报文段，并进入FIN-WAIT-1 终止等待1状态
   - TCP连接释放报文段首部中：
     - 终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认 **请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号**
     - 序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1
     - 确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1
3. TCP服务器进程收到TCP连接释放报文段后，会发送一个**普通**的TCP确认报文段并进入CLOSE-WAIT 关闭等待状态
   - 普通的TCP确认报文段首部中：
     - 确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段
     - 序号seq字段的值设置为v，**普通确认报文不携带数据则不消耗序号**
     - 确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认
4. TCP客户进程到TCP服务器进程这个方向的连接就释放了，客户端进入FIN-WAIT-2 半连接状态，等待TCP服务器进程发出的TCP连接释放报文段；但是如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭
5. TCP服务器进程发送TCP连接释放报文段并进入LAST-ACK最后确认状态
   - 连接释放报文首部：
     - 终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认 
     - 序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送
     - 确认号ack字段的值为u+1，这是对之前收到的客户端TCP连接释放报文段的重复确认
6. TCP客户进程收到服务器TCP连接释放报文段后，必须针对该报文段发送**普通**的TCP确认报文段，之后进入 TIME-WAIT时间等待状态
   - 普通的TCP确认报文首部：
     - 确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段
     - 序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号
     - 确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认

7. TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态，msl 建议为 2min

### 什么是 TCP 粘包？
 - 它不保证数据包的边界

### 如何解决 TCP 粘包问题？

### 如何解决 TCP 粘包问题？

#### UDP会不会粘包

#### TCP粘包问题，如果设置长度而当前没收到这么多怎么办？

#### SYN报文什么下会被丟弃？

#### tcp如何提高传输效率