# TCP 和 UDP

## 一、TCP 和 UDP对比
- UPD 无连接不可靠；支持单播，多播，广播；UDP 是面向应用报文的
- TCP 面向连接可靠（不会出现误码，丢失，重复，乱序）全双工；仅支持单播，即一对一的传输；TCP 是面向字节流的，这是他实现可靠传输，流量控制以及拥塞控制的基础
---
## 二、TCP传输控制协议
[b站讲解](https://www.bilibili.com/video/BV1c4411d7jb?p=58&vd_source=78435c3cefd4783245d9d16d09d19859)
[对应笔记](https://github.com/BloothOfYouth/Computer-Network-Notes/blob/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89.md)
网络层已经打通两台机器连接的基础，但通信是个机器里不同的进程通过端口号区分，进行连接的
---

### 新版本的 chrome 中同一域名下同时最多能建立几个 tcp 连接？
在现代浏览器中，包括最新版本的 Chrome，针对同一域名（也称为同一主机名）同时能够建立的 TCP 连接数是有限制的。这些限制是为了防止单个网站占用过多的网络资源，从而影响其他网站的性能。

对于 Chrome 浏览器，以下是一些常见的连接限制：

- **HTTP/1.1**：同一域名下最多可以建立 6 个并发的 TCP 连接。
- **HTTP/2**：HTTP/2 协议允许在单个 TCP 连接上进行多路复用（multiplexing），这意味着可以在一个连接上同时处理多个请求。因此，HTTP/2 通常只需要一个 TCP 连接来处理同一域名下的所有请求。

这些限制是由浏览器实现的，并且可能会根据浏览器版本和具体实现有所不同。以下是一个简要的总结：

- **HTTP/1.1**：6 个并发连接
- **HTTP/2**：1 个连接（多路复用）

需要注意的是，这些限制是针对同一域名的，并且不同的浏览器可能会有略微不同的实现，但大多数现代浏览器的行为是相似的。

### TCP首部

- **源端口号：**客户端从49151~65535中随机选一个，例如发送 DNS 查询则封装 TCP 首部，源端口号：65535，目的端口号：53，DNS 服务器收到报文发现目的端口号为 53，则交给 DNS 查询进程
- **目的端口号：**
  - UPD 协议：DNS 53
  - TCP 协议：SMTP 25，FTP 20/21,HTTP 80, HTTPS 443
- **序号**
- **确认号**
- **窗口字段**：rwnd 拥塞窗口 cwnd，发送窗口 swnd
- 等等

首部最小 20 字节，最大 60 字节

### 流量控制 （针对双方的缓存空间）
- 超时重传
- 探测报文（也有自己的定时重传）

#### 流量控制窗口和拥塞窗口两者取小值
### 拥塞控制 （针对网络承载能力）
慢开始和拥塞避免（**TCP Tahoe**）
1. **慢开始**：维护一个**慢开始门限** ssthresh；当 cwnd < ssthresh时使用慢开始算法；swnd = cwnd，传输轮次结束后cwnd指数级增长。cwnd > ssthresh时开始使用拥塞避免算法；指初始注入的报文段少，不是指 cwnd 增长速度慢。
2. **拥塞避免**：传输轮次结束后cwnd开始线性增长，发生传输失败，并且重传计时器超时时，判断网络很可能发生了拥塞，将ssthresh更新为当前 cwnd 值的一半，将 cwnd 值减小为 1，使用慢开始算法；当达到慢开始门限时，使用拥塞避免算法；并非指完全避免拥塞，是指控制 cwnd 为线性增长，比较不容易出现拥塞。

快重传和快恢复（**TCP Reno**）有时个别网络报文丢失并非网络发生堵塞，这导致发送方超时重传，误认为网络发生了拥塞，降低了传输效率。
3. **快重传**：采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。
所谓快重传，就是使发送方尽快进行重传，而不是等超时重传计时器超时再重传。
- 要求接收方不要等待自己发送数据时才进行捎带确认，而是要立即发送确认；
- 即使收到了失序的报文段也要立即发出对已收到的报文段的重复确认。
- 发送方一旦收到3个连续的重复确认，就将相应的报文段立即重传，而不是等该报文段的超时重传计时器超时再重传。
- 对于个别丢失的报文段，发送方不会出现超时重传，也就不会误认为出现了拥塞（进而降低拥塞窗口cwnd为1）。使用快重传可以使整个网络的吞吐量提高约20％。
  
4. **快恢复**：发送方一旦收到3个重复确认，就知道现在只是丢失了个别的报文段。于是不启动慢开始算法，而执行快恢复算法；
- 发送方将慢开始门限ssthresh值和拥塞窗口cwnd值调整为当前窗口的一半；开始执行拥塞避免算法。
- 也有的快恢复实现是把快恢复开始时的拥塞窗口cwnd值再增大一些，即等于新的ssthresh + 3。既然发送方收到3个重复的确认，就表明有3个数据报文段已经离开了网络；这3个报文段不再消耗网络资源而是停留在接收方的接收缓存中；
可见现在网络中不是堆积了报文段而是减少了3个报文段。因此可以适当把拥塞窗口扩大些。

### [TCP超时重传时间选择](https://github.com/BloothOfYouth/Computer-Network-Notes/raw/master/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%AC5%E7%AB%A0%EF%BC%88%E8%BF%90%E8%BE%93%E5%B1%82%EF%BC%89.assets/image-20201022153518218.png)
- 如果超时重传时间RTO的值设置得比RTT0的值小很多，这会引起报文段不必要的重传，使网络负荷增大
- 如果超时重传时间RTO的值设置得远大于RTT0的值，这会使重传时间推迟的太长，使网络的空闲时间增大，降低传输效率
- 超时重传时间 RTO 应该略大于加权平均往返时间 TRRs

### TCP可靠传输的实现
TCP 基于字节为单位的滑动窗口来实现可靠传输
### TCP连接建立
解决三个问题
1. 使TCP双方能够确知对方的存在；
2. 使TCP双方能够协商一些参数（如最大窗口值、是否使用窗口扩大选项和时间戳选项以及服务质量等）；
3. 使TCP双方能够对运输实体资源（如缓存大小、连接表中的项目等）进行分配。

流程
1. 服务器和客户端都在CLOSED 关闭状态
2. 服务端首先创建传输控制块，进入LISTEN 监听状态，称为被动打开连接
3. 客户端创建传输控制块，发送TCP连接请求报文段，进入SYN-SENT 同步已发送状态，称为主动打开连接
   - TCP连接请求报文段首部中：
     - **同步位**SYN被设置为1，表明这是一个TCP连接请求报文段
     - 序号字段seq被设置了一个初始值x，作为TCP客户端进程所选择的初始序号 **请注意：TCP规定SYN被设置为1的报文段不能携带数据，但要消耗掉一个序号**
4. 服务端如果同意建立连接，发送TCP连接请求**确认**报文段，进入SYN-RCVD 同步已接收状态
   - TCP连接请求确认报文段首部中：
   - **同步位**SYN**同部位**和**确认位**ACK都设置为1，表明这是一个TCP连接请求确认报文段
   - 序号字段seq被设置了一个初始值y，作为TCP服务器进程所选择的初始序号，
   - 确认号字段ack的值被设置成了x+1，这是对TCP客户进程所选择的初始序号（seq）的确认 **请注意：这个报文段也不能携带数据，因为它是SYN被设置为1的报文段，但同样要消耗掉一个序号**

5. TCP客户进程收到TCP连接请求确认报文段后，还要向TCP服务器进程发送一个**普通**的TCP确认报文段，并进入 ESTABLISHED 连接已连接状态
   - 确认位ACK被设置为1，表明这是一个普通的TCP确认报文段
   - 序号字段seq被设置为x+1，这是因为TCP客户进程发送的第一个TCP报文段的序号为x，所以TCP客户进程发送的第二个报文段的序号为x+1
   - 确认号字段ack被设置为y+1，这是对TCP服务器进程所选择的初始序号的确认 **请注意：TCP规定普通的TCP确认报文段可以携带数据，但如果不携带数据，则不消耗序号**

#### 能否两次握手，最后一次普通确认报文能否省略？

### TCP链接释放
1. 双方都在ESTABLISHED 连接已连接状态
2. 客户端发送TCP连接释放报文段，并进入FIN-WAIT-1 终止等待1状态
   - TCP连接释放报文段首部中：
     - 终止位FIN和确认为ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认 **请注意：TCP规定终止位FIN等于1的报文段即使不携带数据，也要消耗掉一个序号**
     - 序号seq字段的值设置为u，它等于TCP客户进程之前已传送过的数据的最后一个字节的序号加1
     - 确认号ack字段的值设置为v，它等于TCP客户进程之前已收到的、数据的最后一个字节的序号加1
3. TCP服务器进程收到TCP连接释放报文段后，会发送一个**普通**的TCP确认报文段并进入CLOSE-WAIT 关闭等待状态
   - 普通的TCP确认报文段首部中：
     - 确认位ACK的值被设置为1，表明这是一个普通的TCP确认报文段
     - 序号seq字段的值设置为v，**普通确认报文不携带数据则不消耗序号**
     - 确认号ack字段的值设置为u+1，这是对TCP连接释放报文段的确认
4. TCP客户进程到TCP服务器进程这个方向的连接就释放了，客户端进入FIN-WAIT-2 半连接状态，等待TCP服务器进程发出的TCP连接释放报文段；但是如果TCP服务器进程还有数据要发送，TCP客户进程仍要接收，也就是说从TCP服务器进程到TCP客户进程这个方向的连接并未关闭
5. TCP服务器进程发送TCP连接释放报文段并进入LAST-ACK最后确认状态
   - 连接释放报文首部：
     - 终止位FIN和确认位ACK的值都被设置为1，表明这是一个TCP连接释放报文段，同时也对之前收到的报文段进行确认 
     - 序号seq字段的值为w，这是因为在半关闭状态下，TCP服务器进程可能又发送
     - 确认号ack字段的值为u+1，这是对之前收到的客户端TCP连接释放报文段的重复确认
6. TCP客户进程收到服务器TCP连接释放报文段后，必须针对该报文段发送**普通**的TCP确认报文段，之后进入 TIME-WAIT时间等待状态
   - 普通的TCP确认报文首部：
     - 确认为ACK的值被设置为1，表明这是一个普通的TCP确认报文段
     - 序号seq字段的值设置为u+1，这是因为TCP客户进程之前发送的TCP连接释放报文段虽然不携带数据，但要消耗掉一个序号
     - 确认号ack字段的值设置为w+1，这是对所收到的TCP连接释放报文段的确认

7. TCP服务器进程收到该报文段后就进入关闭状态，而TCP客户进程还要进过2MSL后才能进入关闭状态
#### TCP客户进程在发送完最后一个确认报文后，为什么不直接进入关闭状态？而是要进入时间等待状态？
因为时间等待状态以及处于该状态2MSL时长，可以确保TCP服务器进程可以收到最后一个TCP确认报文段而进入关闭状态，
客户端最后一次的确认请求如果丢失，然后客户端直接关闭，则服务端一直超时重传。
客户端等到时，再次收到服务端的释放链接请求，则知道自己刚才发送的确认报文丢失了
### TCP保活计时器的作用
- TCP双方已经建立了连接，后来，TCP客户进程所在的主机突然出现了故障
- TCP服务器进程以后就不能再收到TCP客户进程发来的数据
- 因此，应当有措施使TCP服务器进程不要再白白等待下去

实现：
- TCP服务器进程每收到一次TCP客户进程的数据，就重新设置并启动保活计时器（2小时定时）。
- 若保活计时器定时周期内未收到TCP客户进程发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则每隔75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。
## 三、UDP用户数据协议

### UDP首部
- 源端口
- 目的端口
- 长度
- 检验和

四个字段，每个字段 2 字节一共 8 字节
 