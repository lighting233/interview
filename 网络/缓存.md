# 缓存

## 一、DNS 缓存

DNS缓存的查找过程是DNS解析过程中优化性能的一部分，通过缓存可以减少查询的次数，加快域名解析速度。DNS缓存存在于多个层次，从用户的计算机到权威DNS服务器，每一层都有可能缓存之前查询过的DNS记录。

### DNS缓存查找的层次与过程

1. **浏览器缓存**
   - **检查位置**: 用户的Web浏览器可能会缓存最近访问过的域名及其对应的IP地址。
   - **缓存内容**: 当用户再次访问同一域名时，浏览器会首先查找其缓存。如果缓存中有该域名的记录且未过期，浏览器会直接使用缓存中的IP地址，跳过后续的DNS查询过程。
   - **有效期**: 这个缓存的有效期通常较短，一般是几分钟到几小时。

2. **操作系统缓存（DNS Resolver Cache）**
   - **检查位置**: 如果浏览器缓存中没有找到该域名的记录，查询请求会被转发到操作系统的DNS解析器（DNS Resolver）。操作系统也会维护一个缓存表，存储最近查询过的域名及其对应的IP地址。
   - **缓存内容**: 操作系统缓存中如果有该域名的记录且未过期，它会将IP地址返回给浏览器。
   - **有效期**: 操作系统缓存的有效期也由TTL值决定，通常可以配置。

3. **路由器的DNS缓存**

4. **本地DNS服务器缓存（递归解析器缓存）**
   - **检查位置**: 如果操作系统缓存也没有找到对应记录，查询请求会发送到本地DNS服务器（通常是由互联网服务提供商（ISP）提供的递归解析器）。
   - **缓存内容**: 本地DNS服务器缓存之前处理过的域名解析记录，如果缓存中有该域名的记录且未过期，它会将IP地址返回给操作系统和浏览器。
   - **有效期**: 本地DNS服务器的缓存通常具有较长的有效期，但同样由DNS记录中的TTL值控制。

5. **从根服务器递归查询到权威DNS服务器**
   - **检查位置**: 如果本地DNS服务器的缓存中也没有该域名的记录，查询请求最终会到达权威DNS服务器。虽然权威DNS服务器本质上不缓存数据（它们是数据的权威来源），但它们可以利用缓存减少对根域名服务器或顶级域名服务器的查询。
   - **缓存内容**: 权威DNS服务器的查询结果本身是“权威”的，但为了提高效率，它们可能缓存一些非权威数据，例如上游查询的结果。

### DNS缓存查找过程的简化图示

```
用户输入域名
       ↓
浏览器缓存 —— 查找是否有记录
       ↓
操作系统缓存 —— 查找是否有记录
       ↓
路由器 —— 查找是否有记录
       ↓
本地DNS服务器缓存 —— 查找是否有记录
       ↓
权威DNS服务器 —— 返回IP地址
```

### TTL（生存时间，Time To Live）
- **TTL**: 每一条DNS记录都有一个TTL值，它决定了缓存记录在缓存中的存活时间。TTL过期后，缓存记录将被删除，下一次请求将发起新的DNS查询。

### 小结

- **浏览器缓存** 是查询的第一层，用于加速同一域名的重复访问。
- **操作系统缓存** 是查询的第二层，管理系统级别的域名解析。
- **路由器** 
- **本地DNS服务器缓存** 是查询的第四层，服务于网络内的所有设备。
- **权威DNS服务器** 提供最终的权威响应，如果前几层缓存都没有命中，它将给出IP地址。

每一层的缓存都会在查询过程中依次被检查，直到找到有效的DNS记录，避免不必要的网络请求和延迟。

---
## 二、强缓存
- 检查强缓存，这个阶段不需要发送HTTP请求。==返回的状态码为 **200**==
- 除了服务器设置，前端也可以在，html中使用meta标签：`<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate" />`

- **HTTP/1.0**：Expires， `Expires: Wed, 22 Nov 2019 08:41:00 GMT`
- **HTTP/1.0**：Pragma， Pragma 是一个 HTTP/1.0 的头部字段，主要用途是在 HTTP 请求中包含 `Pragma: no-cache` 指令，这告诉中间缓存服务器不要使用缓存的版本，而是从原始服务器重新获取资源。在 HTTP/1.1 中，Pragma 字段的使用已经被 Cache-Control 头部所取代，后者提供了更多的缓存控制选项。假如 Cache-Control 不存在的话，它的行为与 Cache-Control: no-cache 一致
- **HTTP/1.1**：Cache-Control，`Cache-Control: no-cache, no-store, must-revalidate`他的字段
  - **max-age**: Cache-Control:max-age=3600
  - **private**：这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。
  - **public**：所有内容都将被缓存（客户端和代理服务器都可缓存）
  - **no-cache**: 跳过当前的强缓存，发送HTTP请求，即直接进入协商缓存阶段。**强制缓存重新验证**
  - **no-store**：非常粗暴，不进行任何形式的缓存。
  - **s-maxage**：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。
  - **must-revalidate**：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。must-revalidate生效有个前提，前提就是这个缓存必须已经过期；原来 must-revalidate生效的场景还有一个大前提，那就是 HTTP 规范是允许客户端在某些特殊情况下直接使用过期缓存的，比如校验请求发送失败的时候，还比如有配置一些特殊指令（stale-while-revalidate、stale-if-error等）的时候。revalidate的确能阻止返回过期缓存的行为。

### 缓存标志优先级
paragma -> Cache-control -> expires -> Etag -> last-modified 

### no-cache和no-store的区别
- **no-cache** 指令要求在使用该缓存响应之前，必须先向原始服务器验证其有效性。
- 浏览器会发送一个条件请求（如使用 If-Modified-Since 或 If-None-Match 头部），询问服务器缓存的内容是否仍然有效。如果服务器确认内容没有变化，就会返回一个 304 （未修改）状态码，指示浏览器可以继续使用缓存的版本；如果内容有变化，服务器则会返回新的内容。
- **no-store** 指令则是彻底禁止缓存。它要求浏览器和任何中间代理都不应存储任何关于这个请求或响应的信息。
- 当一个响应标有 no-store 指令时，浏览器和代理必须**立即删除任何已存储的对应缓存项**，并且不得在本地存储请求或响应的任何部分。这意味着每次请求都必须直接发送到服务器，即使网络条件良好，也无法使用缓存的响应。
### Expires和Cache-Control同时存在，以谁为准？
值得注意的是，当Expires和Cache-Control同时存在的时候，**Cache-Control**会优先考虑。

### 通常由哪个服务器来决定缓存响应头？
在一个典型的网站架构中，缓存相关的响应头通常可以在多个层次进行配置，具体取决于你的架构和需求。以下是一些常见的情况：

#### 1. **Nginx 服务器配置缓存响应头**
   - **常见场景**: 如果你有一个 Nginx 服务器作为反向代理或负载均衡器，Nginx 通常是配置缓存响应头的最佳位置。Nginx 可以直接处理静态资源的缓存，或者作为代理时为后端服务器的响应添加缓存头。
   - **配置方法**: 你可以在 Nginx 配置文件中使用 `add_header` 指令添加缓存相关的响应头，如 `Cache-Control`、`Expires`、`ETag` 等。
     ```nginx
     location / {
         proxy_pass http://backend_server;
         add_header Cache-Control "public, max-age=3600";
     }
     ```
   - **优点**: 通过Nginx设置缓存头可以减少后端服务器的负担，并且Nginx在处理静态文件缓存时效率非常高。

#### 2. **Node.js 服务器配置缓存响应头**
   - **常见场景**: 如果你使用 Node.js 服务器（如使用 Express.js 或 Koa.js）处理动态内容，缓存相关的响应头通常也可以在应用代码中配置。Node.js 服务器通常会对动态内容生成缓存头，也可能会为静态文件服务添加缓存策略。
   - **配置方法**: 在 Node.js 应用中，你可以使用中间件或直接在响应对象上设置缓存头。例如：
     ```javascript
     // Express.js 示例
     app.use((req, res, next) => {
         res.set('Cache-Control', 'public, max-age=3600');
         next();
     });
     ```
   - **优点**: 在 Node.js 层面设置缓存头可以根据应用逻辑动态决定缓存策略，提供更细粒度的控制。

#### 3. **CDN（内容分发网络）配置缓存响应头**
   - **常见场景**: 如果你使用了CDN，CDN通常也会对内容进行缓存。CDN可以依据你配置的响应头来决定缓存策略，或者你也可以在CDN的控制台中直接配置缓存策略。
   - **配置方法**: CDN会尊重源站（如Nginx或Node.js服务器）设置的缓存头，但你也可以在CDN的配置中强制覆盖这些策略。例如，某些CDN允许在控制台中设置全局的 `Cache-Control` 或 `Expires` 头。

#### 4. **代理服务器（如反向代理或API网关）配置缓存响应头**
   - **常见场景**: 如果你使用了代理服务器或API网关，它们也可以插入或修改缓存响应头。代理服务器通常用于全局控制和优化跨多个后端服务的缓存策略。
   - **配置方法**: 代理服务器或API网关通常通过其配置文件或控制台来设置缓存头。

#### 5. **源服务器设置缓存响应头**
   - **常见场景**: 在某些情况下，缓存响应头可能会在更靠近源头的服务器上设置，比如你的后端应用服务器（如PHP、Java、Python应用）。
   - **配置方法**: 这些头可以在应用代码中根据业务逻辑动态生成。

#### 综上所述
- **静态资源**的缓存头一般在 **Nginx** 或 **CDN** 层进行配置，因为它们可以高效地处理静态文件的缓存。
- **动态内容**的缓存头通常在 **Node.js** 或其他后端服务器上配置，确保响应头与业务逻辑密切相关。
- **全局缓存策略**有时也可以在 **代理服务器** 或 **API网关** 中设置，适用于整个应用的跨域请求和分布式环境。

在实际项目中，可以根据缓存策略的需求选择在不同层级配置缓存响应头。

---

### 通过多个层级的服务器依次返回响应头，以哪个服务器配置的响应头为准？

当请求经过多个层级的服务器（例如：Nginx、Node.js 应用服务器、CDN 等）时，最终返回给客户端的响应头通常由最靠近客户端的服务器所决定。这个过程中的响应头会经过逐层的处理和可能的修改。具体来说，以哪个服务器配置的响应头为准，取决于以下几个因素：

#### 1. **最靠近客户端的服务器优先**
   - **最后一层服务器优先**: 一般来说，响应头的最终版本由最靠近客户端的服务器（通常是 CDN、Nginx 或反向代理）决定。这是因为该层服务器在接收到后端服务器的响应后，可以直接修改、添加或删除响应头，然后将其发送给客户端。

#### 2. **服务器的默认行为与配置**
   - **覆盖规则**: 每一层服务器在处理请求时，都会先接收到上游服务器（更接近源服务器）的响应，并且有权根据自己的配置对响应头进行修改。例如，Nginx 可以覆盖来自 Node.js 服务器的响应头。
   - **默认行为**: 如果某一层服务器没有显式配置响应头的处理逻辑，则会直接传递上游服务器的响应头，而不做任何修改。

#### 3. **配置中的“追加”与“覆盖”**
   - **追加头部**: 某些服务器（如 Nginx）允许在原有的响应头上追加新的头部信息，而不会覆盖上游服务器设置的头部。这样做时，客户端将会收到所有追加的响应头。
   - **覆盖头部**: 如果某层服务器配置了与上游服务器相同的响应头键（例如 `Cache-Control`），则通常会覆盖上游的设置，以最新设置为准。

#### 4. **特定规则与优先级**
   - **特殊规则**: 某些服务器或代理可能配置了特定的优先级规则，决定哪些响应头应该被保留、修改或丢弃。例如，某些安全性相关的头部（如 `Strict-Transport-Security`）可能会被强制保留。

#### 具体示例分析

假设一个请求从客户端经过 CDN → Nginx → Node.js 应用服务器 → 数据库服务器，然后再依次返回响应，响应头的决定过程如下：

1. **Node.js 应用服务器** 生成响应，并设置响应头，例如 `Cache-Control: no-cache`。
2. **Nginx** 接收到 Node.js 应用服务器的响应，并可以选择保留、修改或覆盖这些响应头。如果 Nginx 配置了 `Cache-Control: public, max-age=3600`，那么这个配置会覆盖 Node.js 设置的响应头。
3. **CDN** 作为最靠近客户端的层，如果它配置了自己的缓存策略，如 `Cache-Control: max-age=86400`，则它会覆盖 Nginx 设置的头部。

最终客户端会收到 CDN 配置的 `Cache-Control: max-age=86400`，即离客户端最近的服务器的响应头配置为准。

#### 总结
- **最靠近客户端的服务器配置优先**: 如果某一层服务器（例如 CDN）修改了响应头，这个修改通常会覆盖上游服务器的配置。
- **中间服务器有能力覆盖或追加头部**: 中间的 Nginx、反向代理等可以修改、追加或保留上游的响应头。
- **最终决定权在最后一层服务器**: 返回给客户端的响应头由最靠近客户端的服务器（最后一层服务器）决定，除非这个服务器选择不修改上游的响应头。

这种机制确保了你可以灵活地在不同层次优化和控制响应头，根据需要选择在不同的层级进行配置。

---

### 三、协商缓存

#### 响应头Last-Modified
- 浏览器接收到后，如果再次请求，会在请求头中携带**If-Modified-Since**字段，这个字段的值也就是服务器传来的最后修改时间。
- `const ctime = statObj.ctime.toGMTString(); res.setHeader('Last-Modified', ctime)`;
- 没有过期返回304，告诉浏览器直接用缓存

#### 响应头ETag
- ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。
- 浏览器接收到ETag的值，会在下次请求时，将这个值作为**If-None-Match**这个字段的内容，并放到请求头中，然后发给服务器。
- `let etag = crpto.createHash('md5').update(content).digest('base64'); res.setHeader('Etag', etag)`

#### Last-Modified和ETag区别？

1. 精度上：
   - Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。
   - 当文件被修改但内容实质上未改变时那么即使内容未变，时间的更新可能导致缓存失效，因为客户端看到的最后修改时间已经变了。如果内容没有实质性变化，ETag 值可能不会变，即使文件的修改时间或其他元数据发生了变化。这样，即使 Last-Modified 时间更新了，使用 ETag 的服务器和客户端仍可以有效利用缓存，因为 ETag 没有变化，表明内容实质上未更新。

2. 性能上：
   - 在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值。

**如果两种方式都支持的话，服务器会优先考虑ETag**

---

### 四、浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：
- (由上到下寻找，找到即返回；找不到则继续)
#### 1.Service Worker
- 一种在浏览器后台运行的JavaScript脚本，它可以拦截和处理网页发出的网络请求，以及管理缓存和离线数据。
- Service Worker可以让网页在离线状态下仍能正常访问，并且可以提高网页的性能和响应速度。
- 它由开发者编写的额外的脚本控制，且缓存位置独立。
- Service Worker 借鉴了 Web Worker的 思路，即让 JS 运行在主线程之外，由于它脱离了浏览器的窗体，因此无法直接访问DOM

##### Service Worker可以实现以下功能：

1. 离线缓存：Service Worker可以缓存网页资源，使得用户在离线状态下仍能访问已经缓存的资源。
2. 推送通知：Service Worker可以接收来自服务器的推送通知，并在用户离线时显示通知。
3. 资源拦截：Service Worker可以拦截网页发出的网络请求，并根据需要返回缓存中的资源或者从服务器请求最新的资源。
4. 跨域通信：Service Worker可以和其他域名的网页进行通信，从而实现一些跨域的功能。

如果 Service Worker 没能命中缓存，一般情况会使用 fetch() 方法继续获取资源。这时浏览器就去 memory cache 或者 disk cache 进行下一次找缓存的工作了。经过 Service Worker 的 fetch() 方法获取的资源，即便它并没有命中 Service Worker 缓存，甚至实际走了**网络请求**，也会标注为 **from ServiceWorker**。
注意：为了保证安全性，Service Worker只能在**HTTPS**协议下使用。
#### 2.Memory Cache
- 当渲染进程结束后，内存缓存也就不存在了。
- 内存中的缓存(与之相对 disk cache 就是硬盘上的缓存)。不受**开发者**控制，也不受 **HTTP 协议头**的约束，是一个黑盒。
- 几乎所有的网络请求资源都会被浏览器自动加入到 memory cache 中。但是也正因为数量很大但是浏览器占用的内存不能无限扩大这样两个因素，memory cache 只能是“短期存储”。通常浏览器窗口中的一个页签TAB 关闭后该次浏览的 memory cache 便失效 (为了给其他 TAB 腾出位置)。而如果极端情况下 (例如一个页面的缓存就占用了超级多的内存)，那可能在 TAB 没关闭之前，排在前面的缓存就已经失效了。
- preloader 请求html，若有js、css等资源，会使用CPU资源进行解析并执行，使用preloader请求来的资源会放到memory cache，供之后解析执行操作。
- preload 显式的预加载资源，也会放到memory cache。比如`<link rel="preload"></link>`会放到memory cache.
- memory cache保证了页面中两个相同请求，都实际请求最多一次，比如（两个src相同的<img>，两个href相同的<link>）

**注意：**在从 memory cache 获取缓存内容时，浏览器会忽视例如 **max-age=0, no-cache** 等头部配置。例如页面上存在几个相同 src 的图片，即便它们可能被设置为不缓存，但依然会从 memory cache 中读取。这是因为 memory cache 只是短期使用，大部分情况生命周期只有一次浏览而已。而 max-age=0 在**语义上**普遍被解读为“**不要在下次浏览时使用**”，所以和 memory cache 并不冲突。

如果想让一个资源进入缓存，就连短期也不行，就使用 **no-store**。存在这个头部配置的话，即便是 memory cache 也不会存储，自然也不会从中读取了。
#### 3.Disk Cache
- disk cache 也叫 HTTP cache（**它遵守 HTTP 协议头中的字段**，平常说的强制缓存，对比缓存，以及 Cache-Control 等）
- 它允许相同的资源在**跨会话，甚至跨站**点的情况下使用，例如两个站点都使用了同一张图片。
- disk cache同样也会面临空间不足的时候，当 disk cache 空间不足时，会根据 LRU（Least Recently Used，最近最少使用）算法淘汰掉最近最少使用的缓存数据，腾出空间存储新的缓存数据

#### 为什么有些资源的状态码是 304，但在控制面板中还可以看见 size 大小？不是应该显示memory cache或Disk Cache吗？
总之，即使状态码为 304，显示的 size 信息主要是关于**响应头部的大小**或者是**缓存资源的大小**，而不是表示有新的数据被传输。这是开发者工具提供的用于调试和性能分析的详细信息。
#### 4.Push Cache
即推送缓存，这是浏览器缓存的最后一道防线。它是 HTTP/2 中的内容，虽然现在应用的并不广泛，但随着 HTTP/2 的推广，它的应用越来越广泛。
