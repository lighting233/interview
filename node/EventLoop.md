
# EventLoop
每个阶段会依次取出队列中的所有回调并执行，直到队列清空或达到系统限制为止。
## node中异步操作
1. **定时器**：setTimeout、setInterval--timmer 队列
2. **I/O操作**：文件读写、数据库操作、网络请求--poll 队列
3. process.nextTick、setImmediate(node独有 )--check 队列

## 执行规则
[视频链接](https://www.bilibili.com/video/BV13A4y1Q7N5/?spm_id_from=333.337.search-card.all.click&vd_source=78435c3cefd4783245d9d16d09d19859)
- 执行完调用栈代码之后，在进入事件循环之前，会检查process.nextTick队列是否为空
- 微任务队列追加在 nextTick队列的后边，事件循环的前边
1. timmer队列
2. pending callbacks：这个阶段主要是执行某些系统层级操作的回调函数。比如说，TCP发生错误时候的错误回调。假如一个TCP socket在尝试建立连接的时候发生了“ECONNREFUSED”错误，则nodejs需要将对应的错误回调入队到pending callback queue中，并马上执行，以此来通知操作系统。
3. idle/prepare：只供nodejs内部来用的阶段。对于开发者而言，几乎可以忽略。
4. poll 队列：在进入poll 阶段之前，event loop会检查timer callback queue是否为空，如果不为空的话，那么event loop就会回退到timer阶段，依次执行所有的timer callback才回到轮询阶段。
   1. 进入到 poll 这步时如果 poll 队列为空，不会立即向下执行，而是会判断check 和 timer 是否为空，如果都为空，则在这里等待，这样设计是为了如果 poll 队列有回调出现，立即响应 I/O事件。
   2. 等待时别的队列出现回调，事件循环恢复执行。
5. check 队列：setImmediate的回调进入 check 队列

## 执行时机
- 打印顺序不一定谁前谁后
- node 中定时器最快的执行时间是 1ms,浏览器是 4ms
```js
setTimeout(() => {
    console.log(1111)
},0);
setImmediate(() => {
    console.log(222)
})
```
- 想要这段代码按顺序执行作出如下调整
```js
fs.readFile(__fileName, () => {
    setTimeout(() => {
        console.log(1111)
    },0);
    setImmediate(() => {
        console.log(222)
    })
})
```

## 详细介绍一下 poll 阶段的超时时间如设置的，为什么设置超时时间？事件循环不是一直在 poll 阶段等待吗？
根据不同的操作系统的实际情况来计算轮询阶段所应该占用event loop的时间长度。

### 1. **`poll` 阶段的工作机制**

`poll` 阶段主要有两个任务：
- 处理已经准备好的 I/O 事件。
- 如果没有 I/O 事件可处理，决定是否需要阻塞并等待新的 I/O 事件到来。

在处理这些任务时，`poll` 阶段可能会发生以下情况：

- **有 I/O 事件需要处理**：立即处理这些 I/O 回调，并不会等待。
- **没有 I/O 事件可处理**：此时可能进入**等待**状态，以便新的 I/O 事件到来。但是等待不会是无限期的，而是有一个最大等待时间（即超时时间），超过这个时间就会继续事件循环的下一阶段。

### 2. **为什么要设置超时时间？**

设置 `poll` 阶段的**超时时间**，是为了防止事件循环在没有事件处理时无限期阻塞在 `poll` 阶段。通过超时机制，Node.js 可以保持事件循环的流畅性，避免阻塞主线程过长时间。这是必要的，原因如下：

- **定时器优先级**：如果有定时器（`setTimeout` 或 `setInterval`）即将到期，`poll` 阶段不能无限期等待，需要给定时器回调执行的机会。因此，`poll` 阶段会在等待到一定时间后提前退出，去处理其他阶段的任务。
- **`setImmediate` 回调**：如果有 `setImmediate` 回调准备好执行，`poll` 阶段也需要退出，以便进入 `check` 阶段执行 `setImmediate`。
- **事件循环的持续性**：Node.js 的事件循环需要不断前进到不同的阶段。如果 `poll` 阶段一直阻塞，其他阶段就无法执行，因此通过超时机制保证事件循环不会卡在某个阶段。

### 3. **如何设置 `poll` 阶段的超时时间？**

`poll` 阶段的**超时时间**是动态设置的，具体取决于以下因素：

1. **是否有定时器到期**：
   - 如果有已经到期或即将到期的定时器，`poll` 阶段的超时时间会设置为最小时间，可能接近 `0`。这样，`poll` 阶段可以快速退出，去处理定时器回调。
   - 如果有定时器即将到期，例如 `setTimeout(fn, 50)`，而当前已经过了 45 毫秒，那么 `poll` 阶段的超时时间会设置为剩余的 5 毫秒，以确保及时处理定时器。

2. **是否有 I/O 事件在等待处理**：
   - 如果没有 I/O 事件需要处理且没有定时器，`poll` 阶段会设置较长的超时时间或无限期阻塞，直到有新的 I/O 事件出现或其他阶段需要执行。
   - 如果有已经完成的 I/O 事件需要处理，`poll` 阶段不会阻塞，它会直接处理这些事件。

3. **`setImmediate` 回调的存在**：
   - 如果有 `setImmediate` 回调已经准备好执行，`poll` 阶段不会设置超时等待，它会立即结束等待并跳到 `check` 阶段。

4. **空闲情况下的等待**：
   - 如果 `poll` 阶段中没有 I/O 事件可以处理，且没有即将到期的定时器，也没有 `setImmediate` 回调，此时 `poll` 阶段可能会阻塞，直到有新的 I/O 事件或定时器到期。这时的超时时间可以是无限期（不设置超时时间），但通常不会超过某个合理的等待时间。

### 4. **总结 `poll` 阶段的超时时间设置逻辑**

- 如果有**定时器即将到期**，`poll` 阶段的超时会被设置为到期时间，以确保及时处理定时器。
- 如果没有 I/O 事件并且没有即将到期的定时器，`poll` 阶段可能会**无限等待**，直到新的 I/O 事件到来。
- 如果有**`setImmediate` 回调**需要处理，`poll` 阶段不会阻塞，会尽快退出并进入 `check` 阶段。
- 如果有 I/O 事件准备好，则立即处理，并不会等待。

### 5. **常见的行为举例**

- **定时器与 I/O**：如果在 `poll` 阶段，存在一个 10 毫秒后到期的定时器，同时没有任何 I/O 事件待处理，那么 `poll` 阶段的超时时间会设置为 10 毫秒，等待这个定时器到期。
- **I/O 完成时**：如果在 `poll` 阶段有已经完成的 I/O 事件，事件循环不会等待，而是立即处理这些 I/O 回调。
- **`setImmediate` 存在时**：如果 `poll` 阶段结束后有 `setImmediate` 任务排队等待执行，`poll` 阶段不会等待，而是立即退出，进入 `check` 阶段处理 `setImmediate` 回调。

### 6. **`poll` 阶段不是一直等待的原因**

`poll` 阶段并不会一直等待，因为它必须与事件循环的其他阶段进行交互，比如处理定时器、微任务、以及 `setImmediate` 回调等。如果事件循环一直停留在 `poll` 阶段等待新的 I/O 事件，其他任务就无法被及时执行。因此通过超时机制和动态管理，使得事件循环能够平衡各类任务的执行顺序。

